model comunidad

-----------Clases-----------

class Community
attributes
	minAgeYoung : Integer
	minAgeAdult : Integer
	minAgeOld : Integer

operations
setMinAge(minY : Integer, minA : Integer, minO : Integer)
	begin
		self.minAgeYoung := minY;
		self.minAgeAdult := minA;
		self.minAgeOld := minO;
	end

die(p: Person)
	begin
		p.deathYear := self.clock.NOW;
		p.beingDead();
		for pe in p.wantToDie do
			delete(pe, p) from Euthanasia;
		end;
		for pe in p.killer do
			delete(p, pe) from Euthanasia;
		end;
		for pe in p.asked do
			delete(p, pe) from ConsentMarriage;
		end;
		for pe in p.ask do
			delete(pe, p) from ConsentMarriage;
		end;
		if(p.askDivorce -> notEmpty) then
			delete(p.activePartner, p) from ConsentDivorce;
		end;
		if(p.askedDivorce -> notEmpty) then
			delete(p, p.activePartner) from ConsentDivorce;
		end;
		if(p.isMarried()) then
			p.activePartner.informDeadPartner();
		end;
	end
	pre esDeMiComunidad: self.person -> includes(p)
	pre noEstaMuerto: not p.isDead
	post estaMuerto: p.isDead
	post relacionesEliminadas: p.wantToDie -> isEmpty and p.killer -> isEmpty and p.asked -> isEmpty and p.ask -> isEmpty and p.askedDivorce -> isEmpty and p.askDivorce -> isEmpty

createMarriage(p1: Person, p2: Person)
	begin
		declare m : Marriage;
		m := new Marriage;
		insert(p1, m) into Couple; --wife
		insert(p2, m) into Couple2; --husband
		m.startYear := self.clock.NOW;
		p1.activePartner := p2;
		p2.activePartner := p1;
		p1.getMarry(p2);
		p2.getMarry(p1);
		delete (p1, p2) from ConsentMarriage;
		delete (p2, p1) from ConsentMarriage;
	end
	pre ningunoCasado: not (p1.isMarried() or p2.isMarried())
	pre ningunoMuertoniNinio: not (p1.isDead or p2.isDead) and not (p1.oclInState(child) or p2.oclInState(child))
	pre tieneQueHaberConsentimiento: p1.asked -> includes(p2) and p2.asked -> includes(p1)
	post eliminadaPedida: p1.asked -> excludes(p2) and p2.asked -> excludes(p1)
	post ambosCasados: p1.isMarried() and p2.isMarried()
	post casadosEntreSi: p1.activePartner = p2 and p2.activePartner = p1

createDivorce(p1: Person, p2: Person)
	begin
		declare m : Marriage;
		m := p1.wife -> union(p1.husband) -> any(m | m.endYear.oclIsUndefined);
		m.endYear := self.clock.NOW;
		p1.activePartner := null;
		p2.activePartner := null;
		p1.getDivorce(p2, m);
		p2.getDivorce(p1, m);
		delete (p1, p2) from ConsentDivorce;
		delete (p2, p1) from ConsentDivorce;
	end
	pre ambosCasados: p1.isMarried() and p2.isMarried()
	pre casadosEntreSi: p1.activePartner = p2 and p2.activePartner = p1
	pre tieneQueHaberConsentimiento: p1.askedDivorce -> includes(p2) and p2.askedDivorce -> includes(p1)
	post ningunoCasado: not (p1.isMarried() or p2.isMarried())

born(nombre : String)
	begin
		declare n : Person;
		n := new Person(nombre);
		insert(self, n) into Belong;
		n.birthYear := self.clock.NOW;
		n.age := 0;
	end

insertPerson(nombre : String, birthYear : Integer)
	begin
		declare n : Person;
		n := new Person(nombre);
		insert(self, n) into Belong;
		n.birthYear := birthYear;
		n.age := self.clock.NOW - n.birthYear;
		n.ajustarFase();
	end
	pre anioMenorIgualClock: birthYear <= self.clock.NOW

end


class Clock
attributes
	NOW : Integer
operations
tick(te : Integer)
	begin
		self.NOW := self.NOW + te;
		for p in self.community.person do
			p.esMiCumple(te);
		end
	end
	--pre : te > 0
	--post timeAdvance : self.NOW = self.NOW@pre + te
end

class Person
attributes
	birthYear : Integer
	deathYear : Integer
	age : Integer 
	isDead : Boolean
	activePartner : Person
	
operations
	isMarried() : Boolean = self.wife -> union(self.husband) -> exists(m | m.endYear.oclIsUndefined)
	marriages() : Integer = if self.wife -> union(self.husband) -> notEmpty then self.wife -> union(self.husband) -> size else 0 endif
	--partner(): Person = if(self.isMarried()) then ( if (self.wife -> select(m | m.endYear.oclIsUndefined) -> notEmpty()) then (self.wife -> any(m | m.endYear.oclIsUndefined).wife) else (self.husband -> any(m | m.endYear.oclIsUndefined).husband) endif) else null endif 
	
	beingDead() --estar muerto
		begin
		end
		pre estarMuerto: self.isDead
		pre noEstaEstadoMuerto: not self.oclInState(dead)
	
	murder(p : Person)
		begin
			p.community.die(p);
		end
		pre noEutanasia: p.killer -> excludes(self)
		pre noSuicidio: p <> self
		pre muertoNoPuedeMatar: not self.isDead
		pre estaViva: not p.isDead
		post estaMuerta: p.isDead
	
	informDeadPartner()
		begin
			declare m : Marriage;
			m := self.wife -> union(self.husband) -> any(m | m.endYear.oclIsUndefined);
			m.endYear := self.community.clock.NOW;
			self.activePartner := null;
		end
		pre parejaHaMuerto: self.activePartner.isDead
		pre yoNoMuerto:  not self.isDead
		post yaNoCasado: not self.isMarried()
		post sinParejaActiva: self.activePartner.oclIsUndefined
	
	permitEuthanasia(p : Person)
		begin
			insert(self, p) into Euthanasia
		end
		pre noSoyYo: p <> self
		pre estamosVivos: not (p.isDead or self.isDead)
		post insertadoCorrectamente: self.killer -> includes(p) and p.wantToDie -> includes(self)
	
	denyEuthanasia(p : Person)
		begin
			delete(self, p) from Euthanasia
		end
		pre leHabiaDadoPermiso: self.killer -> includes(p)
		post yaNoTienePermiso: self.killer -> excludes(p)
	
	esMiCumple(te : Integer)
		begin
			if(not self.isDead) then
			  self.age := self.age + te
			end
		end
		pre positivo: te > 0
		post sumado: not self.isDead implies self.age = self.age@pre + te
		post edadEstaBien: if(self.isDead) then self.age = self.deathYear - self.birthYear else self.age = self.community.clock.NOW - self.birthYear endif

	ajustarFase()
		begin
		end
		pre soloCuandoSaleChildYNoLoEs: self.oclInState(child)
	
	askMarriage(p : Person)
		begin
			insert(self, p) into ConsentMarriage
		end
		pre noSoyYo: p <> self
		pre noEstoyCasado: not self.isMarried()
		pre noEstaCasado: not p.isMarried()
		pre ningunoMuertoniNinio: not (p.isDead or self.isDead) and not (self.oclInState(child) or p.oclInState(child))
		post pedidoCorrectamente: self.asked -> includes(p)
		
	refuseMarriage(p : Person)
		begin
			delete (p, self) from ConsentMarriage
		end 
		pre tieneQueHaberPedido: self.ask -> includes(p)
		post rechazado: self.ask -> excludes(p)
		
	acceptMarriage(p : Person) 
		begin
			if self.asked -> excludes(p) then
				insert(self, p) into ConsentMarriage;
				self.community.createMarriage(self, p)
			else
				self.community.createMarriage(self, p)
			end
		end
		pre tieneQueHaberPedido: self.ask -> includes(p)
		pre noEstoyCasado: not self.isMarried()
		pre ningunoMuerto: not (p.isDead or self.isDead)
		post eliminadaPedida: self.asked -> excludes(p) and p.asked -> excludes(self)
		post matrimonioCreado: self.activePartner = p and p.activePartner = self
	
	getMarry(p : Person)
		begin
		end
		pre ningunoMuerto: not (p.isDead or self.isDead)
		pre tieneQueHaberConsentimiento: self.asked -> includes(p) and p.asked -> includes(self)
		pre matrimonioCreado: self.activePartner = p and p.activePartner = self
		pre estanCasados: self.isMarried() and p.isMarried()
	
	askDivorce() --No pongo argumento person porque solo tiene 1 pareja
		begin
			insert(self, self.activePartner) into ConsentDivorce
		end
		pre estoyCasado: self.isMarried()
		post pedidoCorrectamente: self.askedDivorce -> includes(self.activePartner)
	
	refuseDivorce()
		begin
			delete(self.activePartner, self) from ConsentDivorce
		end
		pre estoyCasado: self.isMarried()
		pre tieneQueHaberPedido: self.askDivorce -> includes(self.activePartner)
		post rechazado: self.askDivorce -> excludes(self.activePartner)
		
	acceptDivorce()
		begin 
			if self.askedDivorce -> excludes(self.activePartner) then
				insert(self, self.activePartner) into ConsentDivorce;
				self.community.createDivorce(self, self.activePartner);
			else 
				self.community.createDivorce(self, self.activePartner);
			end
		end
		pre tieneQueHaberPedido: self.askDivorce -> includes(self.activePartner)
		pre sonMatrimonio: self.activePartner.activePartner = self 
		pre estanCasados: self.isMarried() and self.activePartner.isMarried()
		post eliminadaPedida: self.askedDivorce -> excludes(self.activePartner@pre) and self.activePartner@pre.askedDivorce -> excludes(self)
		post divorciadosCorrectamente: self.activePartner.oclIsUndefined and self.activePartner@pre.activePartner.oclIsUndefined
	
	getDivorce(p : Person, m : Marriage)
		begin
		end
		pre matrimonioFinalizado: not m.endYear.oclIsUndefined
		pre estabanCasados: (m.wife = self and m.husband = p) or (m.wife = p and m.husband = self)
		pre ningunoMuerto: not (p.isDead or self.isDead)	
		pre tieneQueHaberConsentimiento: self.askedDivorce -> includes(p) and p.askedDivorce -> includes(self)
		pre divorciadosCorrectamente: self.activePartner.oclIsUndefined and p.activePartner.oclIsUndefined
		pre noEstanCasados: not(self.isMarried() and p.isMarried())
end

class Marriage
attributes
	startYear : Integer
	endYear : Integer
end



-----------Asociaciones-----------

composition Belong between
Community [1] role community
Person [*] role person
end

aggregation Time between
Community [*] role community
Clock [1] role clock
end

association Couple between
Person [1] role wife
Marriage [*] role husband
end

association Couple2 between
Person [1] role husband
Marriage [*] role wife
end

association ConsentMarriage between
Person [*] role ask --Persona que pide
Person [*] role asked --Persona a la que se lo piden
end

association ConsentDivorce between
Person [0..1] role askDivorce --Persona que pide
Person [0..1] role askedDivorce --Persona a la que se lo piden
end

association Euthanasia between
Person [*] role wantToDie --Persona que pide
Person [*] role killer --Persona a la que se lo piden
end

-----------Restricciones-----------
constraints
--essential constraints
context Person
	inv noFallecerAntesDeNacer:
		self.birthYear <= self.deathYear or self.deathYear.oclIsUndefined
	
	inv noNacerEnFuturo:
		self.birthYear <= self.community.clock.NOW
		
	inv noMorirEnFuturo:
		self.deathYear <= self.community.clock.NOW or self.deathYear.oclIsUndefined
		
	inv birthYearAndAgeUndefined:
		not self.birthYear.oclIsUndefined and not self.age.oclIsUndefined

	inv noDivorcioDeAlguienNoParejaActual:
		(self.askedDivorce -> isEmpty() or self.askedDivorce = self.activePartner) and (self.askDivorce -> isEmpty() or self.askDivorce = self.activePartner)
	
	inv muertosNoCasados:
		self.isDead implies not self.isMarried()
	
context Marriage		
	inv matrimonioNoAcabarAntesEmpezar:
		self.startYear <= self.endYear or self.endYear.oclIsUndefined
		
	inv noMatrimoniosFuturos:
		self.startYear <= self.wife.community.clock.NOW

context Community
	inv edadesMinimasDefinidas:
		not (self.minAgeAdult.oclIsUndefined or self.minAgeOld.oclIsUndefined or self.minAgeYoung.oclIsUndefined)

--business rules
context Clock
	inv soloExisteUnClock:
		Clock.allInstances -> size() <= 1
	
	inv tiempoNoUndefined:
		not self.NOW.oclIsUndefined
	
context Marriage
	inv noCasadaConsigoMisma:
		self.wife <> self.husband
		
	inv noNiniosCasados:
		self.wife.age >= self.wife.community.minAgeYoung and self.husband.age >= self.husband.community.minAgeYoung
	
context Person
	inv noMonogamia:
		self.wife -> select (m | m.endYear.oclIsUndefined) -> union(self.husband -> select (m | m.endYear.oclIsUndefined)) -> size() <= 1

	inv noMatrimoniosSolapados: --no puedes tener 2 matrimonios activos en el mismo intervalo de tiempo 
		self.wife -> union(self.husband) -> forAll( m1, m2 | m1 <> m2 implies m1.startYear >= m2.endYear or m2.startYear >= m1.endYear)

	inv noPermitirEutanasiaAElMismo:
		self.killer -> excludes(self)
		
	inv noPedidaMatrimonioSiCasado:
		self.isMarried() = true implies self.ask -> isEmpty and self.asked -> isEmpty