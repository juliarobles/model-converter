grammar modelConverter.use_language.USE with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate use "http://www.USE.lenguage_use_xtext"

//-------------PRINCIPAL Y TIPOS---------------
Model:
	'model' name=ID ((enums += Enum)* (packagedElement += Type)* constraints=(ConstrainsGeneral)?);
	
Multiplicity:
	minValue+=('*' | IntToString) ('..' maxValue+=('*' | IntToString))? (',' minValue+=('*' | IntToString) ('..' maxValue+=('*' | IntToString))?)*;

IntToString:
	('0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9')+;

AllTypes:
	CollectionType
;

CollectionType:
	('Set' | 'Bag' | 'Sequence') '(' type+=(CollectionType | SimpleTypes | Enum)* ')';

DefaultType:
	'Integer' | 'String' | 'Real' | 'Boolean';

Type:
	Class | Association | AssociationClass;

AllClass:
	Class|AssociationClass;

@Override
terminal SL_COMMENT:
    '--' !('\n'|'\r')* ('\r'? '\n')?;
    
@Override
terminal ML_COMMENT:
    '--' !('\n'|'\r')* ('\r'? '\n')?;

//--------------ENUMERADO--------------
Enum:
	'enum' (name=ID)? '{' (elements+=EnumElement)+ '}';

EnumElement:
	ID (',')?;

//---------------CLASE-----------------
Class:
	(abstract?='abstract')? 'class' name=ID ('<' (generalization+=Generalization)+)? 
		attributes=(AttributesBase)? 
		operations=(OperationsBase)?
		constraints=(ConstraintsBase)? 
	'end';

Generalization:
	general=[AllClass] (',')?;

SimpleTypes:
	defaultType=DefaultType | referended=[AllClass]; //https://www.eclipse.org/forums/index.php/m/553266/?srch=Cannot+call+enum+rule+without+assignment.#msg_553266


//-----------ASOCIACIONES-------------
Association:
	typeAssociation=('association' | 'aggregation' | 'composition') name=ID 'between'		
		(associationEnds+=AssociationEnd)+ 'end';	

AssociationEnd:
	type=[AllClass] '[' mul=Multiplicity ']' ('role' role=ID)? (ordered?='ordered')?;

AssociationClass:
	(abstract?='abstract')? 'associationclass' name=ID ('<' (generalization+=Generalization)+)? 
		'between' (associationEnds+=AssociationEnd)+ 
		attributes=(AttributesBase)? 
		operations=(OperationsBase)? 
		constraints=(ConstraintsBase)? 
	'end';


//-------------ATRIBUTOS---------------
AttributesBase:
	'attributes'
		(attributes+=Attribute)*;

Attribute:
	name=ID ':' type=SimpleTypes;


//------------OPERACIONES--------------
OperationsBase:
	'operations'
		(operations+=OperationType)*;

OperationType:
	OperationComplex | OperationQuery;

OperationQuery:
	operationDeclaration=OperationDeclaration '=' operationbody=OCLExpression (conditions+=ConditionType)*;

OperationComplex:
	operationDeclaration=OperationDeclaration ('begin' (operationbody=OCLExpression)? 'end')? (conditions+=ConditionType)*;

OperationDeclaration:
	name=ID '(' (parameters+=Parameter)* ')' (':' returnType=SimpleTypes)?;

Parameter:
	name=ID ':' type=SimpleTypes (',')?;
	
	
//------------CONSTRAINTS---------------
ConstraintsBase:
	'constraints'
		(invariants+=InvariantDefinition)*;

ConstrainsGeneral:
	'constraints'
		(contexts+=ContextsType)*;

ContextsType:
	InvariantContext | OperationContext;
	
InvariantContext:
	'context' (variablename=ID ':')? classname=[AllClass] (invariants+=InvariantDefinition)*;

InvariantDefinition:
	'inv' (name=ID)? ':' oclexpression=OCLExpression;

OperationContext:
	'context' classname=[AllClass] constrains=OperationConstraints;

OperationConstraints:
	'::' operationDeclaration=OperationDeclaration (conditions+=ConditionType)+;
	
ConditionType:
	Precondition | Postcondition;

Precondition:
	'pre' (name=ID)? ':' oclexpression=OCLExpression;
	
Postcondition:
	'post' (name=ID)? ':' oclexpression=OCLExpression;

OCLExpression hidden (SL_COMMENT):
	STRING; //Esto es como ID pero separado por '', lo que necesito ahora mismo
	
//OCLExpressionQuery hidden (SL_COMMENT):
	//(ID | '.' | '->' | '(' | ')' | ':' | '=' | ';'); 

//AllOCLExpression:
	//(ID | IntToString | '.' | '->' | '(' | ')' | ':' | '=' | ';' | ' ' | '\t')*;
	
//OCLExpression hidden(SL_COMMENT):
	//ocl=AllOCLExpression '\r'? '\n';
	


