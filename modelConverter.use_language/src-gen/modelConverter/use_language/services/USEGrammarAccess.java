/*
 * generated by Xtext 2.25.0
 */
package modelConverter.use_language.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.ocl.xtext.base.services.BaseGrammarAccess;
import org.eclipse.ocl.xtext.essentialocl.services.EssentialOCLGrammarAccess;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class USEGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class ModelUSEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.ModelUSE");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cModelKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cEnumsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cEnumsEnumParserRuleCall_2_0_0 = (RuleCall)cEnumsAssignment_2_0.eContents().get(0);
		private final Assignment cPackagedElementAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cPackagedElementTypeParserRuleCall_2_1_0 = (RuleCall)cPackagedElementAssignment_2_1.eContents().get(0);
		private final Assignment cConstraintsAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cConstraintsConstrainsGeneralParserRuleCall_2_2_0 = (RuleCall)cConstraintsAssignment_2_2.eContents().get(0);
		
		////-------------PRINCIPAL Y TIPOS---------------
		//ModelUSE:
		//    'model' name=ID ((enums += Enum)* (packagedElement += Type)* constraints=(ConstrainsGeneral)?);
		@Override public ParserRule getRule() { return rule; }
		
		//'model' name=ID ((enums += Enum)* (packagedElement += Type)* constraints=(ConstrainsGeneral)?)
		public Group getGroup() { return cGroup; }
		
		//'model'
		public Keyword getModelKeyword_0() { return cModelKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDParserRuleCall_1_0() { return cNameIDParserRuleCall_1_0; }
		
		//((enums += Enum)* (packagedElement += Type)* constraints=(ConstrainsGeneral)?)
		public Group getGroup_2() { return cGroup_2; }
		
		//(enums += Enum)*
		public Assignment getEnumsAssignment_2_0() { return cEnumsAssignment_2_0; }
		
		//Enum
		public RuleCall getEnumsEnumParserRuleCall_2_0_0() { return cEnumsEnumParserRuleCall_2_0_0; }
		
		//(packagedElement += Type)*
		public Assignment getPackagedElementAssignment_2_1() { return cPackagedElementAssignment_2_1; }
		
		//Type
		public RuleCall getPackagedElementTypeParserRuleCall_2_1_0() { return cPackagedElementTypeParserRuleCall_2_1_0; }
		
		//constraints=(ConstrainsGeneral)?
		public Assignment getConstraintsAssignment_2_2() { return cConstraintsAssignment_2_2; }
		
		//(ConstrainsGeneral)
		public RuleCall getConstraintsConstrainsGeneralParserRuleCall_2_2_0() { return cConstraintsConstrainsGeneralParserRuleCall_2_2_0; }
	}
	public class MultiplicityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.Multiplicity");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cMinValueAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cMinValueAlternatives_0_0 = (Alternatives)cMinValueAssignment_0.eContents().get(0);
		private final Keyword cMinValueAsteriskKeyword_0_0_0 = (Keyword)cMinValueAlternatives_0_0.eContents().get(0);
		private final RuleCall cMinValueIntToStringParserRuleCall_0_0_1 = (RuleCall)cMinValueAlternatives_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cMaxValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cMaxValueAlternatives_1_1_0 = (Alternatives)cMaxValueAssignment_1_1.eContents().get(0);
		private final Keyword cMaxValueAsteriskKeyword_1_1_0_0 = (Keyword)cMaxValueAlternatives_1_1_0.eContents().get(0);
		private final RuleCall cMaxValueIntToStringParserRuleCall_1_1_0_1 = (RuleCall)cMaxValueAlternatives_1_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cMinValueAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final Alternatives cMinValueAlternatives_2_1_0 = (Alternatives)cMinValueAssignment_2_1.eContents().get(0);
		private final Keyword cMinValueAsteriskKeyword_2_1_0_0 = (Keyword)cMinValueAlternatives_2_1_0.eContents().get(0);
		private final RuleCall cMinValueIntToStringParserRuleCall_2_1_0_1 = (RuleCall)cMinValueAlternatives_2_1_0.eContents().get(1);
		private final Group cGroup_2_2 = (Group)cGroup_2.eContents().get(2);
		private final Keyword cFullStopFullStopKeyword_2_2_0 = (Keyword)cGroup_2_2.eContents().get(0);
		private final Assignment cMaxValueAssignment_2_2_1 = (Assignment)cGroup_2_2.eContents().get(1);
		private final Alternatives cMaxValueAlternatives_2_2_1_0 = (Alternatives)cMaxValueAssignment_2_2_1.eContents().get(0);
		private final Keyword cMaxValueAsteriskKeyword_2_2_1_0_0 = (Keyword)cMaxValueAlternatives_2_2_1_0.eContents().get(0);
		private final RuleCall cMaxValueIntToStringParserRuleCall_2_2_1_0_1 = (RuleCall)cMaxValueAlternatives_2_2_1_0.eContents().get(1);
		
		//Multiplicity:
		//    minValue+=('*' | IntToString) ('..' maxValue+=('*' | IntToString))? (',' minValue+=('*' | IntToString) ('..' maxValue+=('*' | IntToString))?)*;
		@Override public ParserRule getRule() { return rule; }
		
		//minValue+=('*' | IntToString) ('..' maxValue+=('*' | IntToString))? (',' minValue+=('*' | IntToString) ('..' maxValue+=('*' | IntToString))?)*
		public Group getGroup() { return cGroup; }
		
		//minValue+=('*' | IntToString)
		public Assignment getMinValueAssignment_0() { return cMinValueAssignment_0; }
		
		//('*' | IntToString)
		public Alternatives getMinValueAlternatives_0_0() { return cMinValueAlternatives_0_0; }
		
		//'*'
		public Keyword getMinValueAsteriskKeyword_0_0_0() { return cMinValueAsteriskKeyword_0_0_0; }
		
		//IntToString
		public RuleCall getMinValueIntToStringParserRuleCall_0_0_1() { return cMinValueIntToStringParserRuleCall_0_0_1; }
		
		//('..' maxValue+=('*' | IntToString))?
		public Group getGroup_1() { return cGroup_1; }
		
		//'..'
		public Keyword getFullStopFullStopKeyword_1_0() { return cFullStopFullStopKeyword_1_0; }
		
		//maxValue+=('*' | IntToString)
		public Assignment getMaxValueAssignment_1_1() { return cMaxValueAssignment_1_1; }
		
		//('*' | IntToString)
		public Alternatives getMaxValueAlternatives_1_1_0() { return cMaxValueAlternatives_1_1_0; }
		
		//'*'
		public Keyword getMaxValueAsteriskKeyword_1_1_0_0() { return cMaxValueAsteriskKeyword_1_1_0_0; }
		
		//IntToString
		public RuleCall getMaxValueIntToStringParserRuleCall_1_1_0_1() { return cMaxValueIntToStringParserRuleCall_1_1_0_1; }
		
		//(',' minValue+=('*' | IntToString) ('..' maxValue+=('*' | IntToString))?)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//minValue+=('*' | IntToString)
		public Assignment getMinValueAssignment_2_1() { return cMinValueAssignment_2_1; }
		
		//('*' | IntToString)
		public Alternatives getMinValueAlternatives_2_1_0() { return cMinValueAlternatives_2_1_0; }
		
		//'*'
		public Keyword getMinValueAsteriskKeyword_2_1_0_0() { return cMinValueAsteriskKeyword_2_1_0_0; }
		
		//IntToString
		public RuleCall getMinValueIntToStringParserRuleCall_2_1_0_1() { return cMinValueIntToStringParserRuleCall_2_1_0_1; }
		
		//('..' maxValue+=('*' | IntToString))?
		public Group getGroup_2_2() { return cGroup_2_2; }
		
		//'..'
		public Keyword getFullStopFullStopKeyword_2_2_0() { return cFullStopFullStopKeyword_2_2_0; }
		
		//maxValue+=('*' | IntToString)
		public Assignment getMaxValueAssignment_2_2_1() { return cMaxValueAssignment_2_2_1; }
		
		//('*' | IntToString)
		public Alternatives getMaxValueAlternatives_2_2_1_0() { return cMaxValueAlternatives_2_2_1_0; }
		
		//'*'
		public Keyword getMaxValueAsteriskKeyword_2_2_1_0_0() { return cMaxValueAsteriskKeyword_2_2_1_0_0; }
		
		//IntToString
		public RuleCall getMaxValueIntToStringParserRuleCall_2_2_1_0_1() { return cMaxValueIntToStringParserRuleCall_2_2_1_0_1; }
	}
	public class IntToStringElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.IntToString");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cDigitZeroKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cDigitOneKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cDigitTwoKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cDigitThreeKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cDigitFourKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cDigitFiveKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cDigitSixKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cDigitSevenKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cDigitEightKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cDigitNineKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		
		//IntToString:
		//    ('0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9')+;
		@Override public ParserRule getRule() { return rule; }
		
		//('0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9')+
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'0'
		public Keyword getDigitZeroKeyword_0() { return cDigitZeroKeyword_0; }
		
		//'1'
		public Keyword getDigitOneKeyword_1() { return cDigitOneKeyword_1; }
		
		//'2'
		public Keyword getDigitTwoKeyword_2() { return cDigitTwoKeyword_2; }
		
		//'3'
		public Keyword getDigitThreeKeyword_3() { return cDigitThreeKeyword_3; }
		
		//'4'
		public Keyword getDigitFourKeyword_4() { return cDigitFourKeyword_4; }
		
		//'5'
		public Keyword getDigitFiveKeyword_5() { return cDigitFiveKeyword_5; }
		
		//'6'
		public Keyword getDigitSixKeyword_6() { return cDigitSixKeyword_6; }
		
		//'7'
		public Keyword getDigitSevenKeyword_7() { return cDigitSevenKeyword_7; }
		
		//'8'
		public Keyword getDigitEightKeyword_8() { return cDigitEightKeyword_8; }
		
		//'9'
		public Keyword getDigitNineKeyword_9() { return cDigitNineKeyword_9; }
	}
	public class DefaultTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.DefaultType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cIntegerKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cStringKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cRealKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cBooleanKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//DefaultType:
		//    'Integer' | 'String' | 'Real' | 'Boolean';
		@Override public ParserRule getRule() { return rule; }
		
		//'Integer' | 'String' | 'Real' | 'Boolean'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'Integer'
		public Keyword getIntegerKeyword_0() { return cIntegerKeyword_0; }
		
		//'String'
		public Keyword getStringKeyword_1() { return cStringKeyword_1; }
		
		//'Real'
		public Keyword getRealKeyword_2() { return cRealKeyword_2; }
		
		//'Boolean'
		public Keyword getBooleanKeyword_3() { return cBooleanKeyword_3; }
	}
	public class AllTypesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.AllTypes");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCollectionTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSimpleTypesParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AllTypes:
		//    CollectionType | SimpleTypes;
		@Override public ParserRule getRule() { return rule; }
		
		//CollectionType | SimpleTypes
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CollectionType
		public RuleCall getCollectionTypeParserRuleCall_0() { return cCollectionTypeParserRuleCall_0; }
		
		//SimpleTypes
		public RuleCall getSimpleTypesParserRuleCall_1() { return cSimpleTypesParserRuleCall_1; }
	}
	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cClassParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAssociationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAssociationClassParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Type:
		//    Class | Association | AssociationClass;
		@Override public ParserRule getRule() { return rule; }
		
		//Class | Association | AssociationClass
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Class
		public RuleCall getClassParserRuleCall_0() { return cClassParserRuleCall_0; }
		
		//Association
		public RuleCall getAssociationParserRuleCall_1() { return cAssociationParserRuleCall_1; }
		
		//AssociationClass
		public RuleCall getAssociationClassParserRuleCall_2() { return cAssociationClassParserRuleCall_2; }
	}
	public class CollectionTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.CollectionType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCollectionAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cCollectionAlternatives_0_0 = (Alternatives)cCollectionAssignment_0.eContents().get(0);
		private final Keyword cCollectionSetKeyword_0_0_0 = (Keyword)cCollectionAlternatives_0_0.eContents().get(0);
		private final Keyword cCollectionBagKeyword_0_0_1 = (Keyword)cCollectionAlternatives_0_0.eContents().get(1);
		private final Keyword cCollectionSequenceKeyword_0_0_2 = (Keyword)cCollectionAlternatives_0_0.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeSimpleTypesParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//CollectionType:
		//    collection=('Set' | 'Bag' | 'Sequence') '(' (type+=SimpleTypes)* ')';
		@Override public ParserRule getRule() { return rule; }
		
		//collection=('Set' | 'Bag' | 'Sequence') '(' (type+=SimpleTypes)* ')'
		public Group getGroup() { return cGroup; }
		
		//collection=('Set' | 'Bag' | 'Sequence')
		public Assignment getCollectionAssignment_0() { return cCollectionAssignment_0; }
		
		//('Set' | 'Bag' | 'Sequence')
		public Alternatives getCollectionAlternatives_0_0() { return cCollectionAlternatives_0_0; }
		
		//'Set'
		public Keyword getCollectionSetKeyword_0_0_0() { return cCollectionSetKeyword_0_0_0; }
		
		//'Bag'
		public Keyword getCollectionBagKeyword_0_0_1() { return cCollectionBagKeyword_0_0_1; }
		
		//'Sequence'
		public Keyword getCollectionSequenceKeyword_0_0_2() { return cCollectionSequenceKeyword_0_0_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//(type+=SimpleTypes)*
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//SimpleTypes
		public RuleCall getTypeSimpleTypesParserRuleCall_2_0() { return cTypeSimpleTypesParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class AllClassElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.AllClass");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cClassParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAssociationClassParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AllClass:
		//    Class|AssociationClass;
		@Override public ParserRule getRule() { return rule; }
		
		//Class|AssociationClass
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Class
		public RuleCall getClassParserRuleCall_0() { return cClassParserRuleCall_0; }
		
		//AssociationClass
		public RuleCall getAssociationClassParserRuleCall_1() { return cAssociationClassParserRuleCall_1; }
	}
	public class SimpleTypesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.SimpleTypes");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cDefaultTypeAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cDefaultTypeDefaultTypeParserRuleCall_0_0 = (RuleCall)cDefaultTypeAssignment_0.eContents().get(0);
		private final Assignment cReferendedAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final CrossReference cReferendedAllClassCrossReference_1_0 = (CrossReference)cReferendedAssignment_1.eContents().get(0);
		private final RuleCall cReferendedAllClassIDParserRuleCall_1_0_1 = (RuleCall)cReferendedAllClassCrossReference_1_0.eContents().get(1);
		private final Assignment cReferendedAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final CrossReference cReferendedEnumCrossReference_2_0 = (CrossReference)cReferendedAssignment_2.eContents().get(0);
		private final RuleCall cReferendedEnumIDParserRuleCall_2_0_1 = (RuleCall)cReferendedEnumCrossReference_2_0.eContents().get(1);
		
		//SimpleTypes:
		//    defaultType=DefaultType | referended=[AllClass] | referended=[Enum];
		@Override public ParserRule getRule() { return rule; }
		
		//defaultType=DefaultType | referended=[AllClass] | referended=[Enum]
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//defaultType=DefaultType
		public Assignment getDefaultTypeAssignment_0() { return cDefaultTypeAssignment_0; }
		
		//DefaultType
		public RuleCall getDefaultTypeDefaultTypeParserRuleCall_0_0() { return cDefaultTypeDefaultTypeParserRuleCall_0_0; }
		
		//referended=[AllClass]
		public Assignment getReferendedAssignment_1() { return cReferendedAssignment_1; }
		
		//[AllClass]
		public CrossReference getReferendedAllClassCrossReference_1_0() { return cReferendedAllClassCrossReference_1_0; }
		
		//ID
		public RuleCall getReferendedAllClassIDParserRuleCall_1_0_1() { return cReferendedAllClassIDParserRuleCall_1_0_1; }
		
		//referended=[Enum]
		public Assignment getReferendedAssignment_2() { return cReferendedAssignment_2; }
		
		//[Enum]
		public CrossReference getReferendedEnumCrossReference_2_0() { return cReferendedEnumCrossReference_2_0; }
		
		//ID
		public RuleCall getReferendedEnumIDParserRuleCall_2_0_1() { return cReferendedEnumIDParserRuleCall_2_0_1; }
	}
	public class EnumElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.Enum");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnumKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cElementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cElementsEnumElementParserRuleCall_3_0 = (RuleCall)cElementsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		// //https://www.eclipse.org/forums/index.php/m/553266/?srch=Cannot+call+enum+rule+without+assignment.#msg_553266
		////@Override
		////terminal SL_COMMENT:
		//    //'--' !('\n'|'\r')* ('\r'? '\n')?;
		////@Override
		////terminal ML_COMMENT:
		//    //'--' !('\n'|'\r')* ('\r'? '\n')?;
		////--------------ENUMERADO--------------
		//Enum:
		//    'enum' (name=ID)? '{' (elements+=EnumElement)+ '}';
		@Override public ParserRule getRule() { return rule; }
		
		//'enum' (name=ID)? '{' (elements+=EnumElement)+ '}'
		public Group getGroup() { return cGroup; }
		
		//'enum'
		public Keyword getEnumKeyword_0() { return cEnumKeyword_0; }
		
		//(name=ID)?
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDParserRuleCall_1_0() { return cNameIDParserRuleCall_1_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//(elements+=EnumElement)+
		public Assignment getElementsAssignment_3() { return cElementsAssignment_3; }
		
		//EnumElement
		public RuleCall getElementsEnumElementParserRuleCall_3_0() { return cElementsEnumElementParserRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class EnumElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.EnumElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cCommaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//EnumElement:
		//    ID (',')?;
		@Override public ParserRule getRule() { return rule; }
		
		//ID (',')?
		public Group getGroup() { return cGroup; }
		
		//ID
		public RuleCall getIDParserRuleCall_0() { return cIDParserRuleCall_0; }
		
		//(',')?
		public Keyword getCommaKeyword_1() { return cCommaKeyword_1; }
	}
	public class ClassElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.Class");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAbstractAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cAbstractAbstractKeyword_0_0 = (Keyword)cAbstractAssignment_0.eContents().get(0);
		private final Keyword cClassKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cLessThanSignKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cGeneralizationAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cGeneralizationGeneralizationParserRuleCall_3_1_0 = (RuleCall)cGeneralizationAssignment_3_1.eContents().get(0);
		private final Assignment cAttributesAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cAttributesAttributesBaseParserRuleCall_4_0 = (RuleCall)cAttributesAssignment_4.eContents().get(0);
		private final Assignment cOperationsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cOperationsOperationsBaseParserRuleCall_5_0 = (RuleCall)cOperationsAssignment_5.eContents().get(0);
		private final Assignment cConstraintsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cConstraintsConstraintsBaseParserRuleCall_6_0 = (RuleCall)cConstraintsAssignment_6.eContents().get(0);
		private final Keyword cEndKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		////---------------CLASE-----------------
		//Class:
		//    (abstract?='abstract')? 'class' name=ID ('<' (generalization+=Generalization)+)?
		//        attributes=(AttributesBase)?
		//        operations=(OperationsBase)?
		//        constraints=(ConstraintsBase)?
		//    'end';
		@Override public ParserRule getRule() { return rule; }
		
		//(abstract?='abstract')? 'class' name=ID ('<' (generalization+=Generalization)+)?
		//    attributes=(AttributesBase)?
		//    operations=(OperationsBase)?
		//    constraints=(ConstraintsBase)?
		//'end'
		public Group getGroup() { return cGroup; }
		
		//(abstract?='abstract')?
		public Assignment getAbstractAssignment_0() { return cAbstractAssignment_0; }
		
		//'abstract'
		public Keyword getAbstractAbstractKeyword_0_0() { return cAbstractAbstractKeyword_0_0; }
		
		//'class'
		public Keyword getClassKeyword_1() { return cClassKeyword_1; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDParserRuleCall_2_0() { return cNameIDParserRuleCall_2_0; }
		
		//('<' (generalization+=Generalization)+)?
		public Group getGroup_3() { return cGroup_3; }
		
		//'<'
		public Keyword getLessThanSignKeyword_3_0() { return cLessThanSignKeyword_3_0; }
		
		//(generalization+=Generalization)+
		public Assignment getGeneralizationAssignment_3_1() { return cGeneralizationAssignment_3_1; }
		
		//Generalization
		public RuleCall getGeneralizationGeneralizationParserRuleCall_3_1_0() { return cGeneralizationGeneralizationParserRuleCall_3_1_0; }
		
		//attributes=(AttributesBase)?
		public Assignment getAttributesAssignment_4() { return cAttributesAssignment_4; }
		
		//(AttributesBase)
		public RuleCall getAttributesAttributesBaseParserRuleCall_4_0() { return cAttributesAttributesBaseParserRuleCall_4_0; }
		
		//operations=(OperationsBase)?
		public Assignment getOperationsAssignment_5() { return cOperationsAssignment_5; }
		
		//(OperationsBase)
		public RuleCall getOperationsOperationsBaseParserRuleCall_5_0() { return cOperationsOperationsBaseParserRuleCall_5_0; }
		
		//constraints=(ConstraintsBase)?
		public Assignment getConstraintsAssignment_6() { return cConstraintsAssignment_6; }
		
		//(ConstraintsBase)
		public RuleCall getConstraintsConstraintsBaseParserRuleCall_6_0() { return cConstraintsConstraintsBaseParserRuleCall_6_0; }
		
		//'end'
		public Keyword getEndKeyword_7() { return cEndKeyword_7; }
	}
	public class GeneralizationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.Generalization");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cGeneralAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cGeneralAllClassCrossReference_0_0 = (CrossReference)cGeneralAssignment_0.eContents().get(0);
		private final RuleCall cGeneralAllClassIDParserRuleCall_0_0_1 = (RuleCall)cGeneralAllClassCrossReference_0_0.eContents().get(1);
		private final Keyword cCommaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Generalization:
		//    general=[AllClass] (',')?;
		@Override public ParserRule getRule() { return rule; }
		
		//general=[AllClass] (',')?
		public Group getGroup() { return cGroup; }
		
		//general=[AllClass]
		public Assignment getGeneralAssignment_0() { return cGeneralAssignment_0; }
		
		//[AllClass]
		public CrossReference getGeneralAllClassCrossReference_0_0() { return cGeneralAllClassCrossReference_0_0; }
		
		//ID
		public RuleCall getGeneralAllClassIDParserRuleCall_0_0_1() { return cGeneralAllClassIDParserRuleCall_0_0_1; }
		
		//(',')?
		public Keyword getCommaKeyword_1() { return cCommaKeyword_1; }
	}
	public class AssociationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.Association");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssociationAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cTypeAssociationAlternatives_0_0 = (Alternatives)cTypeAssociationAssignment_0.eContents().get(0);
		private final Keyword cTypeAssociationAssociationKeyword_0_0_0 = (Keyword)cTypeAssociationAlternatives_0_0.eContents().get(0);
		private final Keyword cTypeAssociationAggregationKeyword_0_0_1 = (Keyword)cTypeAssociationAlternatives_0_0.eContents().get(1);
		private final Keyword cTypeAssociationCompositionKeyword_0_0_2 = (Keyword)cTypeAssociationAlternatives_0_0.eContents().get(2);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cBetweenKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAssociationEndsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAssociationEndsAssociationEndParserRuleCall_3_0 = (RuleCall)cAssociationEndsAssignment_3.eContents().get(0);
		private final Keyword cEndKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		////-----------ASOCIACIONES-------------
		//Association:
		//    typeAssociation=('association' | 'aggregation' | 'composition') name=ID 'between'
		//        (associationEnds+=AssociationEnd)+ 'end';
		@Override public ParserRule getRule() { return rule; }
		
		//typeAssociation=('association' | 'aggregation' | 'composition') name=ID 'between'
		//    (associationEnds+=AssociationEnd)+ 'end'
		public Group getGroup() { return cGroup; }
		
		//typeAssociation=('association' | 'aggregation' | 'composition')
		public Assignment getTypeAssociationAssignment_0() { return cTypeAssociationAssignment_0; }
		
		//('association' | 'aggregation' | 'composition')
		public Alternatives getTypeAssociationAlternatives_0_0() { return cTypeAssociationAlternatives_0_0; }
		
		//'association'
		public Keyword getTypeAssociationAssociationKeyword_0_0_0() { return cTypeAssociationAssociationKeyword_0_0_0; }
		
		//'aggregation'
		public Keyword getTypeAssociationAggregationKeyword_0_0_1() { return cTypeAssociationAggregationKeyword_0_0_1; }
		
		//'composition'
		public Keyword getTypeAssociationCompositionKeyword_0_0_2() { return cTypeAssociationCompositionKeyword_0_0_2; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDParserRuleCall_1_0() { return cNameIDParserRuleCall_1_0; }
		
		//'between'
		public Keyword getBetweenKeyword_2() { return cBetweenKeyword_2; }
		
		//(associationEnds+=AssociationEnd)+
		public Assignment getAssociationEndsAssignment_3() { return cAssociationEndsAssignment_3; }
		
		//AssociationEnd
		public RuleCall getAssociationEndsAssociationEndParserRuleCall_3_0() { return cAssociationEndsAssociationEndParserRuleCall_3_0; }
		
		//'end'
		public Keyword getEndKeyword_4() { return cEndKeyword_4; }
	}
	public class AssociationEndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.AssociationEnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeAllClassCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeAllClassIDParserRuleCall_0_0_1 = (RuleCall)cTypeAllClassCrossReference_0_0.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cMulAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cMulMultiplicityParserRuleCall_2_0 = (RuleCall)cMulAssignment_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cRoleKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cRoleAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cRoleIDParserRuleCall_4_1_0 = (RuleCall)cRoleAssignment_4_1.eContents().get(0);
		private final Assignment cOrderedAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final Keyword cOrderedOrderedKeyword_5_0 = (Keyword)cOrderedAssignment_5.eContents().get(0);
		
		//AssociationEnd:
		//    type=[AllClass] '[' mul=Multiplicity ']' ('role' role=ID)? (ordered?='ordered')?;
		@Override public ParserRule getRule() { return rule; }
		
		//type=[AllClass] '[' mul=Multiplicity ']' ('role' role=ID)? (ordered?='ordered')?
		public Group getGroup() { return cGroup; }
		
		//type=[AllClass]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[AllClass]
		public CrossReference getTypeAllClassCrossReference_0_0() { return cTypeAllClassCrossReference_0_0; }
		
		//ID
		public RuleCall getTypeAllClassIDParserRuleCall_0_0_1() { return cTypeAllClassIDParserRuleCall_0_0_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//mul=Multiplicity
		public Assignment getMulAssignment_2() { return cMulAssignment_2; }
		
		//Multiplicity
		public RuleCall getMulMultiplicityParserRuleCall_2_0() { return cMulMultiplicityParserRuleCall_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
		
		//('role' role=ID)?
		public Group getGroup_4() { return cGroup_4; }
		
		//'role'
		public Keyword getRoleKeyword_4_0() { return cRoleKeyword_4_0; }
		
		//role=ID
		public Assignment getRoleAssignment_4_1() { return cRoleAssignment_4_1; }
		
		//ID
		public RuleCall getRoleIDParserRuleCall_4_1_0() { return cRoleIDParserRuleCall_4_1_0; }
		
		//(ordered?='ordered')?
		public Assignment getOrderedAssignment_5() { return cOrderedAssignment_5; }
		
		//'ordered'
		public Keyword getOrderedOrderedKeyword_5_0() { return cOrderedOrderedKeyword_5_0; }
	}
	public class AssociationClassElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.AssociationClass");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAbstractAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cAbstractAbstractKeyword_0_0 = (Keyword)cAbstractAssignment_0.eContents().get(0);
		private final Keyword cAssociationclassKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cLessThanSignKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cGeneralizationAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cGeneralizationGeneralizationParserRuleCall_3_1_0 = (RuleCall)cGeneralizationAssignment_3_1.eContents().get(0);
		private final Keyword cBetweenKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cAssociationEndsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cAssociationEndsAssociationEndParserRuleCall_5_0 = (RuleCall)cAssociationEndsAssignment_5.eContents().get(0);
		private final Assignment cAttributesAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cAttributesAttributesBaseParserRuleCall_6_0 = (RuleCall)cAttributesAssignment_6.eContents().get(0);
		private final Assignment cOperationsAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cOperationsOperationsBaseParserRuleCall_7_0 = (RuleCall)cOperationsAssignment_7.eContents().get(0);
		private final Assignment cConstraintsAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cConstraintsConstraintsBaseParserRuleCall_8_0 = (RuleCall)cConstraintsAssignment_8.eContents().get(0);
		private final Keyword cEndKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//AssociationClass:
		//    (abstract?='abstract')? 'associationclass' name=ID ('<' (generalization+=Generalization)+)?
		//        'between' (associationEnds+=AssociationEnd)+
		//        attributes=(AttributesBase)?
		//        operations=(OperationsBase)?
		//        constraints=(ConstraintsBase)?
		//    'end';
		@Override public ParserRule getRule() { return rule; }
		
		//(abstract?='abstract')? 'associationclass' name=ID ('<' (generalization+=Generalization)+)?
		//    'between' (associationEnds+=AssociationEnd)+
		//    attributes=(AttributesBase)?
		//    operations=(OperationsBase)?
		//    constraints=(ConstraintsBase)?
		//'end'
		public Group getGroup() { return cGroup; }
		
		//(abstract?='abstract')?
		public Assignment getAbstractAssignment_0() { return cAbstractAssignment_0; }
		
		//'abstract'
		public Keyword getAbstractAbstractKeyword_0_0() { return cAbstractAbstractKeyword_0_0; }
		
		//'associationclass'
		public Keyword getAssociationclassKeyword_1() { return cAssociationclassKeyword_1; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDParserRuleCall_2_0() { return cNameIDParserRuleCall_2_0; }
		
		//('<' (generalization+=Generalization)+)?
		public Group getGroup_3() { return cGroup_3; }
		
		//'<'
		public Keyword getLessThanSignKeyword_3_0() { return cLessThanSignKeyword_3_0; }
		
		//(generalization+=Generalization)+
		public Assignment getGeneralizationAssignment_3_1() { return cGeneralizationAssignment_3_1; }
		
		//Generalization
		public RuleCall getGeneralizationGeneralizationParserRuleCall_3_1_0() { return cGeneralizationGeneralizationParserRuleCall_3_1_0; }
		
		//'between'
		public Keyword getBetweenKeyword_4() { return cBetweenKeyword_4; }
		
		//(associationEnds+=AssociationEnd)+
		public Assignment getAssociationEndsAssignment_5() { return cAssociationEndsAssignment_5; }
		
		//AssociationEnd
		public RuleCall getAssociationEndsAssociationEndParserRuleCall_5_0() { return cAssociationEndsAssociationEndParserRuleCall_5_0; }
		
		//attributes=(AttributesBase)?
		public Assignment getAttributesAssignment_6() { return cAttributesAssignment_6; }
		
		//(AttributesBase)
		public RuleCall getAttributesAttributesBaseParserRuleCall_6_0() { return cAttributesAttributesBaseParserRuleCall_6_0; }
		
		//operations=(OperationsBase)?
		public Assignment getOperationsAssignment_7() { return cOperationsAssignment_7; }
		
		//(OperationsBase)
		public RuleCall getOperationsOperationsBaseParserRuleCall_7_0() { return cOperationsOperationsBaseParserRuleCall_7_0; }
		
		//constraints=(ConstraintsBase)?
		public Assignment getConstraintsAssignment_8() { return cConstraintsAssignment_8; }
		
		//(ConstraintsBase)
		public RuleCall getConstraintsConstraintsBaseParserRuleCall_8_0() { return cConstraintsConstraintsBaseParserRuleCall_8_0; }
		
		//'end'
		public Keyword getEndKeyword_9() { return cEndKeyword_9; }
	}
	public class AttributesBaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.AttributesBase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAttributesKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cAttributesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAttributesAttributeParserRuleCall_1_0 = (RuleCall)cAttributesAssignment_1.eContents().get(0);
		
		////-------------ATRIBUTOS---------------
		//AttributesBase:
		//    'attributes'
		//        (attributes+=Attribute)*;
		@Override public ParserRule getRule() { return rule; }
		
		//'attributes'
		//    (attributes+=Attribute)*
		public Group getGroup() { return cGroup; }
		
		//'attributes'
		public Keyword getAttributesKeyword_0() { return cAttributesKeyword_0; }
		
		//(attributes+=Attribute)*
		public Assignment getAttributesAssignment_1() { return cAttributesAssignment_1; }
		
		//Attribute
		public RuleCall getAttributesAttributeParserRuleCall_1_0() { return cAttributesAttributeParserRuleCall_1_0; }
	}
	public class AttributeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.Attribute");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeAllTypesParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		
		//Attribute:
		//    name=ID ':' type=AllTypes;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID ':' type=AllTypes
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDParserRuleCall_0_0() { return cNameIDParserRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=AllTypes
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//AllTypes
		public RuleCall getTypeAllTypesParserRuleCall_2_0() { return cTypeAllTypesParserRuleCall_2_0; }
	}
	public class OperationsBaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.OperationsBase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cOperationsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cOperationsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperationsOperationTypeParserRuleCall_1_0 = (RuleCall)cOperationsAssignment_1.eContents().get(0);
		
		////------------OPERACIONES--------------
		//OperationsBase:
		//    'operations'
		//        (operations+=OperationType)*;
		@Override public ParserRule getRule() { return rule; }
		
		//'operations'
		//    (operations+=OperationType)*
		public Group getGroup() { return cGroup; }
		
		//'operations'
		public Keyword getOperationsKeyword_0() { return cOperationsKeyword_0; }
		
		//(operations+=OperationType)*
		public Assignment getOperationsAssignment_1() { return cOperationsAssignment_1; }
		
		//OperationType
		public RuleCall getOperationsOperationTypeParserRuleCall_1_0() { return cOperationsOperationTypeParserRuleCall_1_0; }
	}
	public class OperationTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.OperationType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cOperationComplexParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cOperationQueryParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//OperationType:
		//    OperationComplex | OperationQuery;
		@Override public ParserRule getRule() { return rule; }
		
		//OperationComplex | OperationQuery
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//OperationComplex
		public RuleCall getOperationComplexParserRuleCall_0() { return cOperationComplexParserRuleCall_0; }
		
		//OperationQuery
		public RuleCall getOperationQueryParserRuleCall_1() { return cOperationQueryParserRuleCall_1; }
	}
	public class OperationQueryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.OperationQuery");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperationDeclarationAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOperationDeclarationOperationDeclarationParserRuleCall_0_0 = (RuleCall)cOperationDeclarationAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cOperationbodyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOperationbodyOCLExpressionParserRuleCall_2_0 = (RuleCall)cOperationbodyAssignment_2.eContents().get(0);
		private final Assignment cConditionsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cConditionsConditionTypeParserRuleCall_3_0 = (RuleCall)cConditionsAssignment_3.eContents().get(0);
		
		//OperationQuery:
		//    operationDeclaration=OperationDeclaration '=' operationbody=OCLExpression (conditions+=ConditionType)*;
		@Override public ParserRule getRule() { return rule; }
		
		//operationDeclaration=OperationDeclaration '=' operationbody=OCLExpression (conditions+=ConditionType)*
		public Group getGroup() { return cGroup; }
		
		//operationDeclaration=OperationDeclaration
		public Assignment getOperationDeclarationAssignment_0() { return cOperationDeclarationAssignment_0; }
		
		//OperationDeclaration
		public RuleCall getOperationDeclarationOperationDeclarationParserRuleCall_0_0() { return cOperationDeclarationOperationDeclarationParserRuleCall_0_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }
		
		//operationbody=OCLExpression
		public Assignment getOperationbodyAssignment_2() { return cOperationbodyAssignment_2; }
		
		//OCLExpression
		public RuleCall getOperationbodyOCLExpressionParserRuleCall_2_0() { return cOperationbodyOCLExpressionParserRuleCall_2_0; }
		
		//(conditions+=ConditionType)*
		public Assignment getConditionsAssignment_3() { return cConditionsAssignment_3; }
		
		//ConditionType
		public RuleCall getConditionsConditionTypeParserRuleCall_3_0() { return cConditionsConditionTypeParserRuleCall_3_0; }
	}
	public class OperationComplexElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.OperationComplex");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperationDeclarationAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOperationDeclarationOperationDeclarationParserRuleCall_0_0 = (RuleCall)cOperationDeclarationAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cBeginKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cOperationbodyAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperationbodyOCLExpressionParserRuleCall_1_1_0 = (RuleCall)cOperationbodyAssignment_1_1.eContents().get(0);
		private final Keyword cEndKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cConditionsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionsConditionTypeParserRuleCall_2_0 = (RuleCall)cConditionsAssignment_2.eContents().get(0);
		
		//OperationComplex:
		//    operationDeclaration=OperationDeclaration ('begin' (operationbody=OCLExpression)? 'end')? (conditions+=ConditionType)*;
		@Override public ParserRule getRule() { return rule; }
		
		//operationDeclaration=OperationDeclaration ('begin' (operationbody=OCLExpression)? 'end')? (conditions+=ConditionType)*
		public Group getGroup() { return cGroup; }
		
		//operationDeclaration=OperationDeclaration
		public Assignment getOperationDeclarationAssignment_0() { return cOperationDeclarationAssignment_0; }
		
		//OperationDeclaration
		public RuleCall getOperationDeclarationOperationDeclarationParserRuleCall_0_0() { return cOperationDeclarationOperationDeclarationParserRuleCall_0_0; }
		
		//('begin' (operationbody=OCLExpression)? 'end')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'begin'
		public Keyword getBeginKeyword_1_0() { return cBeginKeyword_1_0; }
		
		//(operationbody=OCLExpression)?
		public Assignment getOperationbodyAssignment_1_1() { return cOperationbodyAssignment_1_1; }
		
		//OCLExpression
		public RuleCall getOperationbodyOCLExpressionParserRuleCall_1_1_0() { return cOperationbodyOCLExpressionParserRuleCall_1_1_0; }
		
		//'end'
		public Keyword getEndKeyword_1_2() { return cEndKeyword_1_2; }
		
		//(conditions+=ConditionType)*
		public Assignment getConditionsAssignment_2() { return cConditionsAssignment_2; }
		
		//ConditionType
		public RuleCall getConditionsConditionTypeParserRuleCall_2_0() { return cConditionsConditionTypeParserRuleCall_2_0; }
	}
	public class OperationDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.OperationDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParametersAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParametersParameterParserRuleCall_2_0 = (RuleCall)cParametersAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cColonKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cReturnTypeAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cReturnTypeAllTypesParserRuleCall_4_1_0 = (RuleCall)cReturnTypeAssignment_4_1.eContents().get(0);
		
		//OperationDeclaration:
		//    name=ID '(' (parameters+=Parameter)* ')' (':' returnType=AllTypes)?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID '(' (parameters+=Parameter)* ')' (':' returnType=AllTypes)?
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDParserRuleCall_0_0() { return cNameIDParserRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//(parameters+=Parameter)*
		public Assignment getParametersAssignment_2() { return cParametersAssignment_2; }
		
		//Parameter
		public RuleCall getParametersParameterParserRuleCall_2_0() { return cParametersParameterParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//(':' returnType=AllTypes)?
		public Group getGroup_4() { return cGroup_4; }
		
		//':'
		public Keyword getColonKeyword_4_0() { return cColonKeyword_4_0; }
		
		//returnType=AllTypes
		public Assignment getReturnTypeAssignment_4_1() { return cReturnTypeAssignment_4_1; }
		
		//AllTypes
		public RuleCall getReturnTypeAllTypesParserRuleCall_4_1_0() { return cReturnTypeAllTypesParserRuleCall_4_1_0; }
	}
	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.Parameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeAllTypesParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Parameter:
		//    name=ID ':' type=AllTypes (',')?;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID ':' type=AllTypes (',')?
		public Group getGroup() { return cGroup; }
		
		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//ID
		public RuleCall getNameIDParserRuleCall_0_0() { return cNameIDParserRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=AllTypes
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//AllTypes
		public RuleCall getTypeAllTypesParserRuleCall_2_0() { return cTypeAllTypesParserRuleCall_2_0; }
		
		//(',')?
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }
	}
	public class ConstraintsBaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.ConstraintsBase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstraintsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cInvariantsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInvariantsInvariantDefinitionParserRuleCall_1_0 = (RuleCall)cInvariantsAssignment_1.eContents().get(0);
		
		////------------CONSTRAINTS---------------
		//ConstraintsBase:
		//    'constraints'
		//        (invariants+=InvariantDefinition)*;
		@Override public ParserRule getRule() { return rule; }
		
		//'constraints'
		//    (invariants+=InvariantDefinition)*
		public Group getGroup() { return cGroup; }
		
		//'constraints'
		public Keyword getConstraintsKeyword_0() { return cConstraintsKeyword_0; }
		
		//(invariants+=InvariantDefinition)*
		public Assignment getInvariantsAssignment_1() { return cInvariantsAssignment_1; }
		
		//InvariantDefinition
		public RuleCall getInvariantsInvariantDefinitionParserRuleCall_1_0() { return cInvariantsInvariantDefinitionParserRuleCall_1_0; }
	}
	public class ConstrainsGeneralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.ConstrainsGeneral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstraintsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cContextsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cContextsContextsTypeParserRuleCall_1_0 = (RuleCall)cContextsAssignment_1.eContents().get(0);
		
		//ConstrainsGeneral:
		//    'constraints'
		//        (contexts+=ContextsType)*;
		@Override public ParserRule getRule() { return rule; }
		
		//'constraints'
		//    (contexts+=ContextsType)*
		public Group getGroup() { return cGroup; }
		
		//'constraints'
		public Keyword getConstraintsKeyword_0() { return cConstraintsKeyword_0; }
		
		//(contexts+=ContextsType)*
		public Assignment getContextsAssignment_1() { return cContextsAssignment_1; }
		
		//ContextsType
		public RuleCall getContextsContextsTypeParserRuleCall_1_0() { return cContextsContextsTypeParserRuleCall_1_0; }
	}
	public class ContextsTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.ContextsType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cInvariantContextParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cOperationContextParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ContextsType:
		//    InvariantContext | OperationContext;
		@Override public ParserRule getRule() { return rule; }
		
		//InvariantContext | OperationContext
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//InvariantContext
		public RuleCall getInvariantContextParserRuleCall_0() { return cInvariantContextParserRuleCall_0; }
		
		//OperationContext
		public RuleCall getOperationContextParserRuleCall_1() { return cOperationContextParserRuleCall_1; }
	}
	public class InvariantContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.InvariantContext");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cContextKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cVariablenameAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cVariablenameIDParserRuleCall_1_0_0 = (RuleCall)cVariablenameAssignment_1_0.eContents().get(0);
		private final Keyword cColonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cClassnameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cClassnameAllClassCrossReference_2_0 = (CrossReference)cClassnameAssignment_2.eContents().get(0);
		private final RuleCall cClassnameAllClassIDParserRuleCall_2_0_1 = (RuleCall)cClassnameAllClassCrossReference_2_0.eContents().get(1);
		private final Assignment cInvariantsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cInvariantsInvariantDefinitionParserRuleCall_3_0 = (RuleCall)cInvariantsAssignment_3.eContents().get(0);
		
		//InvariantContext:
		//    'context' (variablename=ID ':')? classname=[AllClass] (invariants+=InvariantDefinition)*;
		@Override public ParserRule getRule() { return rule; }
		
		//'context' (variablename=ID ':')? classname=[AllClass] (invariants+=InvariantDefinition)*
		public Group getGroup() { return cGroup; }
		
		//'context'
		public Keyword getContextKeyword_0() { return cContextKeyword_0; }
		
		//(variablename=ID ':')?
		public Group getGroup_1() { return cGroup_1; }
		
		//variablename=ID
		public Assignment getVariablenameAssignment_1_0() { return cVariablenameAssignment_1_0; }
		
		//ID
		public RuleCall getVariablenameIDParserRuleCall_1_0_0() { return cVariablenameIDParserRuleCall_1_0_0; }
		
		//':'
		public Keyword getColonKeyword_1_1() { return cColonKeyword_1_1; }
		
		//classname=[AllClass]
		public Assignment getClassnameAssignment_2() { return cClassnameAssignment_2; }
		
		//[AllClass]
		public CrossReference getClassnameAllClassCrossReference_2_0() { return cClassnameAllClassCrossReference_2_0; }
		
		//ID
		public RuleCall getClassnameAllClassIDParserRuleCall_2_0_1() { return cClassnameAllClassIDParserRuleCall_2_0_1; }
		
		//(invariants+=InvariantDefinition)*
		public Assignment getInvariantsAssignment_3() { return cInvariantsAssignment_3; }
		
		//InvariantDefinition
		public RuleCall getInvariantsInvariantDefinitionParserRuleCall_3_0() { return cInvariantsInvariantDefinitionParserRuleCall_3_0; }
	}
	public class InvariantDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.InvariantDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInvKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cOclexpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOclexpressionOCLExpressionParserRuleCall_3_0 = (RuleCall)cOclexpressionAssignment_3.eContents().get(0);
		
		//InvariantDefinition:
		//    'inv' (name=ID)? ':' oclexpression=OCLExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//'inv' (name=ID)? ':' oclexpression=OCLExpression
		public Group getGroup() { return cGroup; }
		
		//'inv'
		public Keyword getInvKeyword_0() { return cInvKeyword_0; }
		
		//(name=ID)?
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDParserRuleCall_1_0() { return cNameIDParserRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//oclexpression=OCLExpression
		public Assignment getOclexpressionAssignment_3() { return cOclexpressionAssignment_3; }
		
		//OCLExpression
		public RuleCall getOclexpressionOCLExpressionParserRuleCall_3_0() { return cOclexpressionOCLExpressionParserRuleCall_3_0; }
	}
	public class OperationContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.OperationContext");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cContextKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cClassnameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cClassnameAllClassCrossReference_1_0 = (CrossReference)cClassnameAssignment_1.eContents().get(0);
		private final RuleCall cClassnameAllClassIDParserRuleCall_1_0_1 = (RuleCall)cClassnameAllClassCrossReference_1_0.eContents().get(1);
		private final Assignment cConstrainsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConstrainsOperationConstraintsParserRuleCall_2_0 = (RuleCall)cConstrainsAssignment_2.eContents().get(0);
		
		//OperationContext:
		//    'context' classname=[AllClass] constrains=OperationConstraints;
		@Override public ParserRule getRule() { return rule; }
		
		//'context' classname=[AllClass] constrains=OperationConstraints
		public Group getGroup() { return cGroup; }
		
		//'context'
		public Keyword getContextKeyword_0() { return cContextKeyword_0; }
		
		//classname=[AllClass]
		public Assignment getClassnameAssignment_1() { return cClassnameAssignment_1; }
		
		//[AllClass]
		public CrossReference getClassnameAllClassCrossReference_1_0() { return cClassnameAllClassCrossReference_1_0; }
		
		//ID
		public RuleCall getClassnameAllClassIDParserRuleCall_1_0_1() { return cClassnameAllClassIDParserRuleCall_1_0_1; }
		
		//constrains=OperationConstraints
		public Assignment getConstrainsAssignment_2() { return cConstrainsAssignment_2; }
		
		//OperationConstraints
		public RuleCall getConstrainsOperationConstraintsParserRuleCall_2_0() { return cConstrainsOperationConstraintsParserRuleCall_2_0; }
	}
	public class OperationConstraintsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.OperationConstraints");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cColonColonKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cOperationDeclarationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperationDeclarationOperationDeclarationParserRuleCall_1_0 = (RuleCall)cOperationDeclarationAssignment_1.eContents().get(0);
		private final Assignment cConditionsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionsConditionTypeParserRuleCall_2_0 = (RuleCall)cConditionsAssignment_2.eContents().get(0);
		
		//OperationConstraints:
		//    '::' operationDeclaration=OperationDeclaration (conditions+=ConditionType)+;
		@Override public ParserRule getRule() { return rule; }
		
		//'::' operationDeclaration=OperationDeclaration (conditions+=ConditionType)+
		public Group getGroup() { return cGroup; }
		
		//'::'
		public Keyword getColonColonKeyword_0() { return cColonColonKeyword_0; }
		
		//operationDeclaration=OperationDeclaration
		public Assignment getOperationDeclarationAssignment_1() { return cOperationDeclarationAssignment_1; }
		
		//OperationDeclaration
		public RuleCall getOperationDeclarationOperationDeclarationParserRuleCall_1_0() { return cOperationDeclarationOperationDeclarationParserRuleCall_1_0; }
		
		//(conditions+=ConditionType)+
		public Assignment getConditionsAssignment_2() { return cConditionsAssignment_2; }
		
		//ConditionType
		public RuleCall getConditionsConditionTypeParserRuleCall_2_0() { return cConditionsConditionTypeParserRuleCall_2_0; }
	}
	public class ConditionTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.ConditionType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPreconditionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPostconditionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ConditionType:
		//    Precondition | Postcondition;
		@Override public ParserRule getRule() { return rule; }
		
		//Precondition | Postcondition
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Precondition
		public RuleCall getPreconditionParserRuleCall_0() { return cPreconditionParserRuleCall_0; }
		
		//Postcondition
		public RuleCall getPostconditionParserRuleCall_1() { return cPostconditionParserRuleCall_1; }
	}
	public class PreconditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.Precondition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPreKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cOclexpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOclexpressionOCLExpressionParserRuleCall_3_0 = (RuleCall)cOclexpressionAssignment_3.eContents().get(0);
		
		//Precondition:
		//    'pre' (name=ID)? ':' oclexpression=OCLExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//'pre' (name=ID)? ':' oclexpression=OCLExpression
		public Group getGroup() { return cGroup; }
		
		//'pre'
		public Keyword getPreKeyword_0() { return cPreKeyword_0; }
		
		//(name=ID)?
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDParserRuleCall_1_0() { return cNameIDParserRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//oclexpression=OCLExpression
		public Assignment getOclexpressionAssignment_3() { return cOclexpressionAssignment_3; }
		
		//OCLExpression
		public RuleCall getOclexpressionOCLExpressionParserRuleCall_3_0() { return cOclexpressionOCLExpressionParserRuleCall_3_0; }
	}
	public class PostconditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.Postcondition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPostKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cOclexpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cOclexpressionOCLExpressionParserRuleCall_3_0 = (RuleCall)cOclexpressionAssignment_3.eContents().get(0);
		
		//Postcondition:
		//    'post' (name=ID)? ':' oclexpression=OCLExpression;
		@Override public ParserRule getRule() { return rule; }
		
		//'post' (name=ID)? ':' oclexpression=OCLExpression
		public Group getGroup() { return cGroup; }
		
		//'post'
		public Keyword getPostKeyword_0() { return cPostKeyword_0; }
		
		//(name=ID)?
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDParserRuleCall_1_0() { return cNameIDParserRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//oclexpression=OCLExpression
		public Assignment getOclexpressionAssignment_3() { return cOclexpressionAssignment_3; }
		
		//OCLExpression
		public RuleCall getOclexpressionOCLExpressionParserRuleCall_3_0() { return cOclexpressionOCLExpressionParserRuleCall_3_0; }
	}
	public class OCLExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "modelConverter.use_language.USE.OCLExpression");
		private final Assignment cOwnedExpressionAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cOwnedExpressionExpCSParserRuleCall_0 = (RuleCall)cOwnedExpressionAssignment.eContents().get(0);
		
		////OCLExpression hidden (SL_COMMENT):
		//    //STRING; //Esto es como ID pero separado por '', lo que necesito ahora mismo
		////OCLExpressionQuery hidden (SL_COMMENT):
		//    //(ID | '.' | '->' | '(' | ')' | ':' | '=' | ';');
		////AllOCLExpression:
		//    //(ID | IntToString | '.' | '->' | '(' | ')' | ':' | '=' | ';' | ' ' | '\t')*;
		////OCLExpression hidden(SL_COMMENT):
		//    //ocl=AllOCLExpression '\r'? '\n';
		//OCLExpression returns ContextCS hidden(SL_COMMENT):
		//    ownedExpression=ExpCS;
		@Override public ParserRule getRule() { return rule; }
		
		//ownedExpression=ExpCS
		public Assignment getOwnedExpressionAssignment() { return cOwnedExpressionAssignment; }
		
		//ExpCS
		public RuleCall getOwnedExpressionExpCSParserRuleCall_0() { return cOwnedExpressionExpCSParserRuleCall_0; }
	}
	
	
	private final ModelUSEElements pModelUSE;
	private final MultiplicityElements pMultiplicity;
	private final IntToStringElements pIntToString;
	private final DefaultTypeElements pDefaultType;
	private final AllTypesElements pAllTypes;
	private final TypeElements pType;
	private final CollectionTypeElements pCollectionType;
	private final AllClassElements pAllClass;
	private final SimpleTypesElements pSimpleTypes;
	private final EnumElements pEnum;
	private final EnumElementElements pEnumElement;
	private final ClassElements pClass;
	private final GeneralizationElements pGeneralization;
	private final AssociationElements pAssociation;
	private final AssociationEndElements pAssociationEnd;
	private final AssociationClassElements pAssociationClass;
	private final AttributesBaseElements pAttributesBase;
	private final AttributeElements pAttribute;
	private final OperationsBaseElements pOperationsBase;
	private final OperationTypeElements pOperationType;
	private final OperationQueryElements pOperationQuery;
	private final OperationComplexElements pOperationComplex;
	private final OperationDeclarationElements pOperationDeclaration;
	private final ParameterElements pParameter;
	private final ConstraintsBaseElements pConstraintsBase;
	private final ConstrainsGeneralElements pConstrainsGeneral;
	private final ContextsTypeElements pContextsType;
	private final InvariantContextElements pInvariantContext;
	private final InvariantDefinitionElements pInvariantDefinition;
	private final OperationContextElements pOperationContext;
	private final OperationConstraintsElements pOperationConstraints;
	private final ConditionTypeElements pConditionType;
	private final PreconditionElements pPrecondition;
	private final PostconditionElements pPostcondition;
	private final OCLExpressionElements pOCLExpression;
	
	private final Grammar grammar;
	
	private final EssentialOCLGrammarAccess gaEssentialOCL;
	
	private final BaseGrammarAccess gaBase;

	@Inject
	public USEGrammarAccess(GrammarProvider grammarProvider,
			EssentialOCLGrammarAccess gaEssentialOCL,
			BaseGrammarAccess gaBase) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaEssentialOCL = gaEssentialOCL;
		this.gaBase = gaBase;
		this.pModelUSE = new ModelUSEElements();
		this.pMultiplicity = new MultiplicityElements();
		this.pIntToString = new IntToStringElements();
		this.pDefaultType = new DefaultTypeElements();
		this.pAllTypes = new AllTypesElements();
		this.pType = new TypeElements();
		this.pCollectionType = new CollectionTypeElements();
		this.pAllClass = new AllClassElements();
		this.pSimpleTypes = new SimpleTypesElements();
		this.pEnum = new EnumElements();
		this.pEnumElement = new EnumElementElements();
		this.pClass = new ClassElements();
		this.pGeneralization = new GeneralizationElements();
		this.pAssociation = new AssociationElements();
		this.pAssociationEnd = new AssociationEndElements();
		this.pAssociationClass = new AssociationClassElements();
		this.pAttributesBase = new AttributesBaseElements();
		this.pAttribute = new AttributeElements();
		this.pOperationsBase = new OperationsBaseElements();
		this.pOperationType = new OperationTypeElements();
		this.pOperationQuery = new OperationQueryElements();
		this.pOperationComplex = new OperationComplexElements();
		this.pOperationDeclaration = new OperationDeclarationElements();
		this.pParameter = new ParameterElements();
		this.pConstraintsBase = new ConstraintsBaseElements();
		this.pConstrainsGeneral = new ConstrainsGeneralElements();
		this.pContextsType = new ContextsTypeElements();
		this.pInvariantContext = new InvariantContextElements();
		this.pInvariantDefinition = new InvariantDefinitionElements();
		this.pOperationContext = new OperationContextElements();
		this.pOperationConstraints = new OperationConstraintsElements();
		this.pConditionType = new ConditionTypeElements();
		this.pPrecondition = new PreconditionElements();
		this.pPostcondition = new PostconditionElements();
		this.pOCLExpression = new OCLExpressionElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("modelConverter.use_language.USE".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public EssentialOCLGrammarAccess getEssentialOCLGrammarAccess() {
		return gaEssentialOCL;
	}
	
	public BaseGrammarAccess getBaseGrammarAccess() {
		return gaBase;
	}

	
	////-------------PRINCIPAL Y TIPOS---------------
	//ModelUSE:
	//    'model' name=ID ((enums += Enum)* (packagedElement += Type)* constraints=(ConstrainsGeneral)?);
	public ModelUSEElements getModelUSEAccess() {
		return pModelUSE;
	}
	
	public ParserRule getModelUSERule() {
		return getModelUSEAccess().getRule();
	}
	
	//Multiplicity:
	//    minValue+=('*' | IntToString) ('..' maxValue+=('*' | IntToString))? (',' minValue+=('*' | IntToString) ('..' maxValue+=('*' | IntToString))?)*;
	public MultiplicityElements getMultiplicityAccess() {
		return pMultiplicity;
	}
	
	public ParserRule getMultiplicityRule() {
		return getMultiplicityAccess().getRule();
	}
	
	//IntToString:
	//    ('0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9')+;
	public IntToStringElements getIntToStringAccess() {
		return pIntToString;
	}
	
	public ParserRule getIntToStringRule() {
		return getIntToStringAccess().getRule();
	}
	
	//DefaultType:
	//    'Integer' | 'String' | 'Real' | 'Boolean';
	public DefaultTypeElements getDefaultTypeAccess() {
		return pDefaultType;
	}
	
	public ParserRule getDefaultTypeRule() {
		return getDefaultTypeAccess().getRule();
	}
	
	//AllTypes:
	//    CollectionType | SimpleTypes;
	public AllTypesElements getAllTypesAccess() {
		return pAllTypes;
	}
	
	public ParserRule getAllTypesRule() {
		return getAllTypesAccess().getRule();
	}
	
	//Type:
	//    Class | Association | AssociationClass;
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}
	
	//CollectionType:
	//    collection=('Set' | 'Bag' | 'Sequence') '(' (type+=SimpleTypes)* ')';
	public CollectionTypeElements getCollectionTypeAccess() {
		return pCollectionType;
	}
	
	public ParserRule getCollectionTypeRule() {
		return getCollectionTypeAccess().getRule();
	}
	
	//AllClass:
	//    Class|AssociationClass;
	public AllClassElements getAllClassAccess() {
		return pAllClass;
	}
	
	public ParserRule getAllClassRule() {
		return getAllClassAccess().getRule();
	}
	
	//SimpleTypes:
	//    defaultType=DefaultType | referended=[AllClass] | referended=[Enum];
	public SimpleTypesElements getSimpleTypesAccess() {
		return pSimpleTypes;
	}
	
	public ParserRule getSimpleTypesRule() {
		return getSimpleTypesAccess().getRule();
	}
	
	// //https://www.eclipse.org/forums/index.php/m/553266/?srch=Cannot+call+enum+rule+without+assignment.#msg_553266
	////@Override
	////terminal SL_COMMENT:
	//    //'--' !('\n'|'\r')* ('\r'? '\n')?;
	////@Override
	////terminal ML_COMMENT:
	//    //'--' !('\n'|'\r')* ('\r'? '\n')?;
	////--------------ENUMERADO--------------
	//Enum:
	//    'enum' (name=ID)? '{' (elements+=EnumElement)+ '}';
	public EnumElements getEnumAccess() {
		return pEnum;
	}
	
	public ParserRule getEnumRule() {
		return getEnumAccess().getRule();
	}
	
	//EnumElement:
	//    ID (',')?;
	public EnumElementElements getEnumElementAccess() {
		return pEnumElement;
	}
	
	public ParserRule getEnumElementRule() {
		return getEnumElementAccess().getRule();
	}
	
	////---------------CLASE-----------------
	//Class:
	//    (abstract?='abstract')? 'class' name=ID ('<' (generalization+=Generalization)+)?
	//        attributes=(AttributesBase)?
	//        operations=(OperationsBase)?
	//        constraints=(ConstraintsBase)?
	//    'end';
	public ClassElements getClassAccess() {
		return pClass;
	}
	
	public ParserRule getClassRule() {
		return getClassAccess().getRule();
	}
	
	//Generalization:
	//    general=[AllClass] (',')?;
	public GeneralizationElements getGeneralizationAccess() {
		return pGeneralization;
	}
	
	public ParserRule getGeneralizationRule() {
		return getGeneralizationAccess().getRule();
	}
	
	////-----------ASOCIACIONES-------------
	//Association:
	//    typeAssociation=('association' | 'aggregation' | 'composition') name=ID 'between'
	//        (associationEnds+=AssociationEnd)+ 'end';
	public AssociationElements getAssociationAccess() {
		return pAssociation;
	}
	
	public ParserRule getAssociationRule() {
		return getAssociationAccess().getRule();
	}
	
	//AssociationEnd:
	//    type=[AllClass] '[' mul=Multiplicity ']' ('role' role=ID)? (ordered?='ordered')?;
	public AssociationEndElements getAssociationEndAccess() {
		return pAssociationEnd;
	}
	
	public ParserRule getAssociationEndRule() {
		return getAssociationEndAccess().getRule();
	}
	
	//AssociationClass:
	//    (abstract?='abstract')? 'associationclass' name=ID ('<' (generalization+=Generalization)+)?
	//        'between' (associationEnds+=AssociationEnd)+
	//        attributes=(AttributesBase)?
	//        operations=(OperationsBase)?
	//        constraints=(ConstraintsBase)?
	//    'end';
	public AssociationClassElements getAssociationClassAccess() {
		return pAssociationClass;
	}
	
	public ParserRule getAssociationClassRule() {
		return getAssociationClassAccess().getRule();
	}
	
	////-------------ATRIBUTOS---------------
	//AttributesBase:
	//    'attributes'
	//        (attributes+=Attribute)*;
	public AttributesBaseElements getAttributesBaseAccess() {
		return pAttributesBase;
	}
	
	public ParserRule getAttributesBaseRule() {
		return getAttributesBaseAccess().getRule();
	}
	
	//Attribute:
	//    name=ID ':' type=AllTypes;
	public AttributeElements getAttributeAccess() {
		return pAttribute;
	}
	
	public ParserRule getAttributeRule() {
		return getAttributeAccess().getRule();
	}
	
	////------------OPERACIONES--------------
	//OperationsBase:
	//    'operations'
	//        (operations+=OperationType)*;
	public OperationsBaseElements getOperationsBaseAccess() {
		return pOperationsBase;
	}
	
	public ParserRule getOperationsBaseRule() {
		return getOperationsBaseAccess().getRule();
	}
	
	//OperationType:
	//    OperationComplex | OperationQuery;
	public OperationTypeElements getOperationTypeAccess() {
		return pOperationType;
	}
	
	public ParserRule getOperationTypeRule() {
		return getOperationTypeAccess().getRule();
	}
	
	//OperationQuery:
	//    operationDeclaration=OperationDeclaration '=' operationbody=OCLExpression (conditions+=ConditionType)*;
	public OperationQueryElements getOperationQueryAccess() {
		return pOperationQuery;
	}
	
	public ParserRule getOperationQueryRule() {
		return getOperationQueryAccess().getRule();
	}
	
	//OperationComplex:
	//    operationDeclaration=OperationDeclaration ('begin' (operationbody=OCLExpression)? 'end')? (conditions+=ConditionType)*;
	public OperationComplexElements getOperationComplexAccess() {
		return pOperationComplex;
	}
	
	public ParserRule getOperationComplexRule() {
		return getOperationComplexAccess().getRule();
	}
	
	//OperationDeclaration:
	//    name=ID '(' (parameters+=Parameter)* ')' (':' returnType=AllTypes)?;
	public OperationDeclarationElements getOperationDeclarationAccess() {
		return pOperationDeclaration;
	}
	
	public ParserRule getOperationDeclarationRule() {
		return getOperationDeclarationAccess().getRule();
	}
	
	//Parameter:
	//    name=ID ':' type=AllTypes (',')?;
	public ParameterElements getParameterAccess() {
		return pParameter;
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}
	
	////------------CONSTRAINTS---------------
	//ConstraintsBase:
	//    'constraints'
	//        (invariants+=InvariantDefinition)*;
	public ConstraintsBaseElements getConstraintsBaseAccess() {
		return pConstraintsBase;
	}
	
	public ParserRule getConstraintsBaseRule() {
		return getConstraintsBaseAccess().getRule();
	}
	
	//ConstrainsGeneral:
	//    'constraints'
	//        (contexts+=ContextsType)*;
	public ConstrainsGeneralElements getConstrainsGeneralAccess() {
		return pConstrainsGeneral;
	}
	
	public ParserRule getConstrainsGeneralRule() {
		return getConstrainsGeneralAccess().getRule();
	}
	
	//ContextsType:
	//    InvariantContext | OperationContext;
	public ContextsTypeElements getContextsTypeAccess() {
		return pContextsType;
	}
	
	public ParserRule getContextsTypeRule() {
		return getContextsTypeAccess().getRule();
	}
	
	//InvariantContext:
	//    'context' (variablename=ID ':')? classname=[AllClass] (invariants+=InvariantDefinition)*;
	public InvariantContextElements getInvariantContextAccess() {
		return pInvariantContext;
	}
	
	public ParserRule getInvariantContextRule() {
		return getInvariantContextAccess().getRule();
	}
	
	//InvariantDefinition:
	//    'inv' (name=ID)? ':' oclexpression=OCLExpression;
	public InvariantDefinitionElements getInvariantDefinitionAccess() {
		return pInvariantDefinition;
	}
	
	public ParserRule getInvariantDefinitionRule() {
		return getInvariantDefinitionAccess().getRule();
	}
	
	//OperationContext:
	//    'context' classname=[AllClass] constrains=OperationConstraints;
	public OperationContextElements getOperationContextAccess() {
		return pOperationContext;
	}
	
	public ParserRule getOperationContextRule() {
		return getOperationContextAccess().getRule();
	}
	
	//OperationConstraints:
	//    '::' operationDeclaration=OperationDeclaration (conditions+=ConditionType)+;
	public OperationConstraintsElements getOperationConstraintsAccess() {
		return pOperationConstraints;
	}
	
	public ParserRule getOperationConstraintsRule() {
		return getOperationConstraintsAccess().getRule();
	}
	
	//ConditionType:
	//    Precondition | Postcondition;
	public ConditionTypeElements getConditionTypeAccess() {
		return pConditionType;
	}
	
	public ParserRule getConditionTypeRule() {
		return getConditionTypeAccess().getRule();
	}
	
	//Precondition:
	//    'pre' (name=ID)? ':' oclexpression=OCLExpression;
	public PreconditionElements getPreconditionAccess() {
		return pPrecondition;
	}
	
	public ParserRule getPreconditionRule() {
		return getPreconditionAccess().getRule();
	}
	
	//Postcondition:
	//    'post' (name=ID)? ':' oclexpression=OCLExpression;
	public PostconditionElements getPostconditionAccess() {
		return pPostcondition;
	}
	
	public ParserRule getPostconditionRule() {
		return getPostconditionAccess().getRule();
	}
	
	////OCLExpression hidden (SL_COMMENT):
	//    //STRING; //Esto es como ID pero separado por '', lo que necesito ahora mismo
	////OCLExpressionQuery hidden (SL_COMMENT):
	//    //(ID | '.' | '->' | '(' | ')' | ':' | '=' | ';');
	////AllOCLExpression:
	//    //(ID | IntToString | '.' | '->' | '(' | ')' | ':' | '=' | ';' | ' ' | '\t')*;
	////OCLExpression hidden(SL_COMMENT):
	//    //ocl=AllOCLExpression '\r'? '\n';
	//OCLExpression returns ContextCS hidden(SL_COMMENT):
	//    ownedExpression=ExpCS;
	public OCLExpressionElements getOCLExpressionAccess() {
		return pOCLExpression;
	}
	
	public ParserRule getOCLExpressionRule() {
		return getOCLExpressionAccess().getRule();
	}
	
	////generate essentialOCLCST "http://www.eclipse.org/ocl/3.0.0/EssentialOCLCST"
	//Model returns ContextCS:
	//    ownedExpression=ExpCS;
	public EssentialOCLGrammarAccess.ModelElements getModelAccess() {
		return gaEssentialOCL.getModelAccess();
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	///** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
	//EssentialOCLReservedKeyword:
	//    'and'
	//    | 'and2'
	//    | 'else'
	//    | 'endif'
	//    | 'if'
	//    | 'implies'
	//    | 'implies2'
	//    | 'in'
	//    | 'let'
	//    | 'not'
	//    | 'not2'
	//    | 'or'
	//    | 'or2'
	//    | 'then'
	//    | 'xor'
	//    | 'xor2';
	public EssentialOCLGrammarAccess.EssentialOCLReservedKeywordElements getEssentialOCLReservedKeywordAccess() {
		return gaEssentialOCL.getEssentialOCLReservedKeywordAccess();
	}
	
	public ParserRule getEssentialOCLReservedKeywordRule() {
		return getEssentialOCLReservedKeywordAccess().getRule();
	}
	
	///** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
	//EssentialOCLUnaryOperatorName:
	//    '-' | 'not' | 'not2';
	public EssentialOCLGrammarAccess.EssentialOCLUnaryOperatorNameElements getEssentialOCLUnaryOperatorNameAccess() {
		return gaEssentialOCL.getEssentialOCLUnaryOperatorNameAccess();
	}
	
	public ParserRule getEssentialOCLUnaryOperatorNameRule() {
		return getEssentialOCLUnaryOperatorNameAccess().getRule();
	}
	
	///** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
	//EssentialOCLInfixOperatorName:
	//    '*' | '/' | '+' | '-' | '>' | '<' | '>=' | '<=' | '=' | '<>' | 'and' | 'and2' | 'implies' | 'implies2' | 'or' | 'or2' | 'xor' | 'xor2';
	public EssentialOCLGrammarAccess.EssentialOCLInfixOperatorNameElements getEssentialOCLInfixOperatorNameAccess() {
		return gaEssentialOCL.getEssentialOCLInfixOperatorNameAccess();
	}
	
	public ParserRule getEssentialOCLInfixOperatorNameRule() {
		return getEssentialOCLInfixOperatorNameAccess().getRule();
	}
	
	///** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
	//EssentialOCLNavigationOperatorName:
	//    '.' | '->' | '?.' | '?->';
	public EssentialOCLGrammarAccess.EssentialOCLNavigationOperatorNameElements getEssentialOCLNavigationOperatorNameAccess() {
		return gaEssentialOCL.getEssentialOCLNavigationOperatorNameAccess();
	}
	
	public ParserRule getEssentialOCLNavigationOperatorNameRule() {
		return getEssentialOCLNavigationOperatorNameAccess().getRule();
	}
	
	//BinaryOperatorName:
	//    InfixOperatorName | NavigationOperatorName;
	public EssentialOCLGrammarAccess.BinaryOperatorNameElements getBinaryOperatorNameAccess() {
		return gaEssentialOCL.getBinaryOperatorNameAccess();
	}
	
	public ParserRule getBinaryOperatorNameRule() {
		return getBinaryOperatorNameAccess().getRule();
	}
	
	//InfixOperatorName:             // Intended to be overrideable
	//    EssentialOCLInfixOperatorName;
	public EssentialOCLGrammarAccess.InfixOperatorNameElements getInfixOperatorNameAccess() {
		return gaEssentialOCL.getInfixOperatorNameAccess();
	}
	
	public ParserRule getInfixOperatorNameRule() {
		return getInfixOperatorNameAccess().getRule();
	}
	
	//NavigationOperatorName:     // Intended to be overrideable
	//    EssentialOCLNavigationOperatorName;
	public EssentialOCLGrammarAccess.NavigationOperatorNameElements getNavigationOperatorNameAccess() {
		return gaEssentialOCL.getNavigationOperatorNameAccess();
	}
	
	public ParserRule getNavigationOperatorNameRule() {
		return getNavigationOperatorNameAccess().getRule();
	}
	
	//UnaryOperatorName:             // Intended to be overrideable
	//    EssentialOCLUnaryOperatorName;
	public EssentialOCLGrammarAccess.UnaryOperatorNameElements getUnaryOperatorNameAccess() {
		return gaEssentialOCL.getUnaryOperatorNameAccess();
	}
	
	public ParserRule getUnaryOperatorNameRule() {
		return getUnaryOperatorNameAccess().getRule();
	}
	
	////---------------------------------------------------------------------
	////  Names
	////---------------------------------------------------------------------
	///** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
	//EssentialOCLUnrestrictedName returns ecore::EString:
	//    Identifier;
	public EssentialOCLGrammarAccess.EssentialOCLUnrestrictedNameElements getEssentialOCLUnrestrictedNameAccess() {
		return gaEssentialOCL.getEssentialOCLUnrestrictedNameAccess();
	}
	
	public ParserRule getEssentialOCLUnrestrictedNameRule() {
		return getEssentialOCLUnrestrictedNameAccess().getRule();
	}
	
	//@Override
	//UnrestrictedName returns ecore::EString: // Intended to be overridden
	//    EssentialOCLUnrestrictedName;
	public EssentialOCLGrammarAccess.UnrestrictedNameElements getUnrestrictedNameAccess() {
		return gaEssentialOCL.getUnrestrictedNameAccess();
	}
	
	public ParserRule getUnrestrictedNameRule() {
		return getUnrestrictedNameAccess().getRule();
	}
	
	///** <<<This is a join point for derived grammars - replace with a more disciplined grammar extensibility>>> */
	//EssentialOCLUnreservedName returns ecore::EString:
	//    UnrestrictedName
	//|    CollectionTypeIdentifier
	//|    PrimitiveTypeIdentifier
	//|    'Map'
	//|    'Tuple'
	//;
	public EssentialOCLGrammarAccess.EssentialOCLUnreservedNameElements getEssentialOCLUnreservedNameAccess() {
		return gaEssentialOCL.getEssentialOCLUnreservedNameAccess();
	}
	
	public ParserRule getEssentialOCLUnreservedNameRule() {
		return getEssentialOCLUnreservedNameAccess().getRule();
	}
	
	//@Override
	//UnreservedName returns ecore::EString: // Intended to be overridden
	//    EssentialOCLUnreservedName;
	public EssentialOCLGrammarAccess.UnreservedNameElements getUnreservedNameAccess() {
		return gaEssentialOCL.getUnreservedNameAccess();
	}
	
	public ParserRule getUnreservedNameRule() {
		return getUnreservedNameAccess().getRule();
	}
	
	//URIPathNameCS returns base::PathNameCS:
	//    ownedPathElements+=URIFirstPathElementCS ('::' ownedPathElements+=NextPathElementCS)*;
	public EssentialOCLGrammarAccess.URIPathNameCSElements getURIPathNameCSAccess() {
		return gaEssentialOCL.getURIPathNameCSAccess();
	}
	
	public ParserRule getURIPathNameCSRule() {
		return getURIPathNameCSAccess().getRule();
	}
	
	//URIFirstPathElementCS returns base::PathElementCS:
	//    referredElement=[pivot::NamedElement|UnrestrictedName] | {base::PathElementWithURICS} referredElement=[pivot::Namespace|URI];
	public EssentialOCLGrammarAccess.URIFirstPathElementCSElements getURIFirstPathElementCSAccess() {
		return gaEssentialOCL.getURIFirstPathElementCSAccess();
	}
	
	public ParserRule getURIFirstPathElementCSRule() {
		return getURIFirstPathElementCSAccess().getRule();
	}
	
	//SimplePathNameCS returns base::PathNameCS:
	//    ownedPathElements+=FirstPathElementCS;
	public EssentialOCLGrammarAccess.SimplePathNameCSElements getSimplePathNameCSAccess() {
		return gaEssentialOCL.getSimplePathNameCSAccess();
	}
	
	public ParserRule getSimplePathNameCSRule() {
		return getSimplePathNameCSAccess().getRule();
	}
	
	////---------------------------------------------------------------------
	////  Types
	////---------------------------------------------------------------------
	//PrimitiveTypeIdentifier:
	//    'Boolean'
	//    | 'Integer'
	//    | 'Real'
	//    | 'String'
	//    | 'UnlimitedNatural'
	//    | 'OclAny'
	//    | 'OclInvalid'
	//    | 'OclVoid';
	public EssentialOCLGrammarAccess.PrimitiveTypeIdentifierElements getPrimitiveTypeIdentifierAccess() {
		return gaEssentialOCL.getPrimitiveTypeIdentifierAccess();
	}
	
	public ParserRule getPrimitiveTypeIdentifierRule() {
		return getPrimitiveTypeIdentifierAccess().getRule();
	}
	
	//PrimitiveTypeCS returns base::PrimitiveTypeRefCS:
	//    name=PrimitiveTypeIdentifier;
	public EssentialOCLGrammarAccess.PrimitiveTypeCSElements getPrimitiveTypeCSAccess() {
		return gaEssentialOCL.getPrimitiveTypeCSAccess();
	}
	
	public ParserRule getPrimitiveTypeCSRule() {
		return getPrimitiveTypeCSAccess().getRule();
	}
	
	//CollectionTypeIdentifier returns ecore::EString:
	//    'Set'
	//    | 'Bag'
	//    | 'Sequence'
	//    | 'Collection'
	//    | 'OrderedSet';
	public EssentialOCLGrammarAccess.CollectionTypeIdentifierElements getCollectionTypeIdentifierAccess() {
		return gaEssentialOCL.getCollectionTypeIdentifierAccess();
	}
	
	public ParserRule getCollectionTypeIdentifierRule() {
		return getCollectionTypeIdentifierAccess().getRule();
	}
	
	//CollectionTypeCS returns CollectionTypeCS:
	//    name=CollectionTypeIdentifier ('(' ownedType=TypeExpWithoutMultiplicityCS ownedCollectionMultiplicity=MultiplicityCS? ')')?;
	public EssentialOCLGrammarAccess.CollectionTypeCSElements getCollectionTypeCSAccess() {
		return gaEssentialOCL.getCollectionTypeCSAccess();
	}
	
	public ParserRule getCollectionTypeCSRule() {
		return getCollectionTypeCSAccess().getRule();
	}
	
	//MapTypeCS returns MapTypeCS:
	//    name='Map' ('(' ownedKeyType=TypeExpCS ',' ownedValueType=TypeExpCS ')')?;
	public EssentialOCLGrammarAccess.MapTypeCSElements getMapTypeCSAccess() {
		return gaEssentialOCL.getMapTypeCSAccess();
	}
	
	public ParserRule getMapTypeCSRule() {
		return getMapTypeCSAccess().getRule();
	}
	
	//TupleTypeCS returns base::TupleTypeCS:
	//    name='Tuple' ('(' (ownedParts+=TuplePartCS (',' ownedParts+=TuplePartCS)*)? ')')?;
	public EssentialOCLGrammarAccess.TupleTypeCSElements getTupleTypeCSAccess() {
		return gaEssentialOCL.getTupleTypeCSAccess();
	}
	
	public ParserRule getTupleTypeCSRule() {
		return getTupleTypeCSAccess().getRule();
	}
	
	//TuplePartCS returns base::TuplePartCS:
	//    name=UnrestrictedName ':' ownedType=TypeExpCS;
	public EssentialOCLGrammarAccess.TuplePartCSElements getTuplePartCSAccess() {
		return gaEssentialOCL.getTuplePartCSAccess();
	}
	
	public ParserRule getTuplePartCSRule() {
		return getTuplePartCSAccess().getRule();
	}
	
	////---------------------------------------------------------------------
	////  Literals
	////---------------------------------------------------------------------
	//CollectionLiteralExpCS returns CollectionLiteralExpCS:
	//    ownedType=CollectionTypeCS
	//    '{' (ownedParts+=CollectionLiteralPartCS
	//    (',' ownedParts+=CollectionLiteralPartCS)*)?
	//    '}';
	public EssentialOCLGrammarAccess.CollectionLiteralExpCSElements getCollectionLiteralExpCSAccess() {
		return gaEssentialOCL.getCollectionLiteralExpCSAccess();
	}
	
	public ParserRule getCollectionLiteralExpCSRule() {
		return getCollectionLiteralExpCSAccess().getRule();
	}
	
	//CollectionLiteralPartCS returns CollectionLiteralPartCS:
	//    (ownedExpression=ExpCS ('..' ownedLastExpression=ExpCS)?) | ownedExpression=PatternExpCS;
	public EssentialOCLGrammarAccess.CollectionLiteralPartCSElements getCollectionLiteralPartCSAccess() {
		return gaEssentialOCL.getCollectionLiteralPartCSAccess();
	}
	
	public ParserRule getCollectionLiteralPartCSRule() {
		return getCollectionLiteralPartCSAccess().getRule();
	}
	
	//CollectionPatternCS returns CollectionPatternCS:
	//    ownedType=CollectionTypeCS
	//    '{' (ownedParts+=PatternExpCS
	//    (',' ownedParts+=PatternExpCS)*
	//    ('++' restVariableName=Identifier))?
	//    '}';
	public EssentialOCLGrammarAccess.CollectionPatternCSElements getCollectionPatternCSAccess() {
		return gaEssentialOCL.getCollectionPatternCSAccess();
	}
	
	public ParserRule getCollectionPatternCSRule() {
		return getCollectionPatternCSAccess().getRule();
	}
	
	//ShadowPartCS returns ShadowPartCS:        // PatternPartCS
	//    (referredProperty=[pivot::Property|UnrestrictedName] '='ownedInitExpression=(ExpCS|PatternExpCS))
	//    | ownedInitExpression=StringLiteralExpCS;
	public EssentialOCLGrammarAccess.ShadowPartCSElements getShadowPartCSAccess() {
		return gaEssentialOCL.getShadowPartCSAccess();
	}
	
	public ParserRule getShadowPartCSRule() {
		return getShadowPartCSAccess().getRule();
	}
	
	//PatternExpCS:
	//    patternVariableName=UnrestrictedName? ':' ownedPatternType=TypeExpCS;
	public EssentialOCLGrammarAccess.PatternExpCSElements getPatternExpCSAccess() {
		return gaEssentialOCL.getPatternExpCSAccess();
	}
	
	public ParserRule getPatternExpCSRule() {
		return getPatternExpCSAccess().getRule();
	}
	
	//LambdaLiteralExpCS returns LambdaLiteralExpCS:
	//    'Lambda' '{' ownedExpressionCS=ExpCS '}';
	public EssentialOCLGrammarAccess.LambdaLiteralExpCSElements getLambdaLiteralExpCSAccess() {
		return gaEssentialOCL.getLambdaLiteralExpCSAccess();
	}
	
	public ParserRule getLambdaLiteralExpCSRule() {
		return getLambdaLiteralExpCSAccess().getRule();
	}
	
	//MapLiteralExpCS returns MapLiteralExpCS:
	//    ownedType=MapTypeCS '{' (ownedParts+=MapLiteralPartCS (',' ownedParts+=MapLiteralPartCS)*)? '}';
	public EssentialOCLGrammarAccess.MapLiteralExpCSElements getMapLiteralExpCSAccess() {
		return gaEssentialOCL.getMapLiteralExpCSAccess();
	}
	
	public ParserRule getMapLiteralExpCSRule() {
		return getMapLiteralExpCSAccess().getRule();
	}
	
	//MapLiteralPartCS returns MapLiteralPartCS:
	//    ownedKey=ExpCS '<-' ownedValue=ExpCS;
	public EssentialOCLGrammarAccess.MapLiteralPartCSElements getMapLiteralPartCSAccess() {
		return gaEssentialOCL.getMapLiteralPartCSAccess();
	}
	
	public ParserRule getMapLiteralPartCSRule() {
		return getMapLiteralPartCSAccess().getRule();
	}
	
	//PrimitiveLiteralExpCS returns PrimitiveLiteralExpCS:
	//    NumberLiteralExpCS
	//    | StringLiteralExpCS
	//    | BooleanLiteralExpCS
	//    | UnlimitedNaturalLiteralExpCS
	//    | InvalidLiteralExpCS
	//    | NullLiteralExpCS;
	public EssentialOCLGrammarAccess.PrimitiveLiteralExpCSElements getPrimitiveLiteralExpCSAccess() {
		return gaEssentialOCL.getPrimitiveLiteralExpCSAccess();
	}
	
	public ParserRule getPrimitiveLiteralExpCSRule() {
		return getPrimitiveLiteralExpCSAccess().getRule();
	}
	
	//TupleLiteralExpCS returns TupleLiteralExpCS:
	//    'Tuple' '{' ownedParts+=TupleLiteralPartCS (',' ownedParts+=TupleLiteralPartCS)* '}';
	public EssentialOCLGrammarAccess.TupleLiteralExpCSElements getTupleLiteralExpCSAccess() {
		return gaEssentialOCL.getTupleLiteralExpCSAccess();
	}
	
	public ParserRule getTupleLiteralExpCSRule() {
		return getTupleLiteralExpCSAccess().getRule();
	}
	
	//TupleLiteralPartCS returns TupleLiteralPartCS:
	//    name=UnrestrictedName (':' ownedType=TypeExpCS)? '=' ownedInitExpression=ExpCS;
	public EssentialOCLGrammarAccess.TupleLiteralPartCSElements getTupleLiteralPartCSAccess() {
		return gaEssentialOCL.getTupleLiteralPartCSAccess();
	}
	
	public ParserRule getTupleLiteralPartCSRule() {
		return getTupleLiteralPartCSAccess().getRule();
	}
	
	//NumberLiteralExpCS returns NumberLiteralExpCS:
	//    symbol=NUMBER_LITERAL;
	public EssentialOCLGrammarAccess.NumberLiteralExpCSElements getNumberLiteralExpCSAccess() {
		return gaEssentialOCL.getNumberLiteralExpCSAccess();
	}
	
	public ParserRule getNumberLiteralExpCSRule() {
		return getNumberLiteralExpCSAccess().getRule();
	}
	
	//StringLiteralExpCS returns StringLiteralExpCS:
	//    segments+=StringLiteral+;
	public EssentialOCLGrammarAccess.StringLiteralExpCSElements getStringLiteralExpCSAccess() {
		return gaEssentialOCL.getStringLiteralExpCSAccess();
	}
	
	public ParserRule getStringLiteralExpCSRule() {
		return getStringLiteralExpCSAccess().getRule();
	}
	
	//BooleanLiteralExpCS returns BooleanLiteralExpCS:
	//    symbol='true'
	//    | symbol='false';
	public EssentialOCLGrammarAccess.BooleanLiteralExpCSElements getBooleanLiteralExpCSAccess() {
		return gaEssentialOCL.getBooleanLiteralExpCSAccess();
	}
	
	public ParserRule getBooleanLiteralExpCSRule() {
		return getBooleanLiteralExpCSAccess().getRule();
	}
	
	//UnlimitedNaturalLiteralExpCS returns UnlimitedNaturalLiteralExpCS:
	//    {UnlimitedNaturalLiteralExpCS} '*';
	public EssentialOCLGrammarAccess.UnlimitedNaturalLiteralExpCSElements getUnlimitedNaturalLiteralExpCSAccess() {
		return gaEssentialOCL.getUnlimitedNaturalLiteralExpCSAccess();
	}
	
	public ParserRule getUnlimitedNaturalLiteralExpCSRule() {
		return getUnlimitedNaturalLiteralExpCSAccess().getRule();
	}
	
	//InvalidLiteralExpCS returns InvalidLiteralExpCS:
	//    {InvalidLiteralExpCS} 'invalid';
	public EssentialOCLGrammarAccess.InvalidLiteralExpCSElements getInvalidLiteralExpCSAccess() {
		return gaEssentialOCL.getInvalidLiteralExpCSAccess();
	}
	
	public ParserRule getInvalidLiteralExpCSRule() {
		return getInvalidLiteralExpCSAccess().getRule();
	}
	
	//NullLiteralExpCS returns NullLiteralExpCS:
	//    {NullLiteralExpCS} 'null';
	public EssentialOCLGrammarAccess.NullLiteralExpCSElements getNullLiteralExpCSAccess() {
		return gaEssentialOCL.getNullLiteralExpCSAccess();
	}
	
	public ParserRule getNullLiteralExpCSRule() {
		return getNullLiteralExpCSAccess().getRule();
	}
	
	//TypeLiteralCS returns base::TypedRefCS:
	//    PrimitiveTypeCS
	//    | CollectionTypeCS
	//    | MapTypeCS
	//    | TupleTypeCS;
	public EssentialOCLGrammarAccess.TypeLiteralCSElements getTypeLiteralCSAccess() {
		return gaEssentialOCL.getTypeLiteralCSAccess();
	}
	
	public ParserRule getTypeLiteralCSRule() {
		return getTypeLiteralCSAccess().getRule();
	}
	
	//TypeLiteralWithMultiplicityCS returns base::TypedRefCS:
	//    TypeLiteralCS ownedMultiplicity=MultiplicityCS?;
	public EssentialOCLGrammarAccess.TypeLiteralWithMultiplicityCSElements getTypeLiteralWithMultiplicityCSAccess() {
		return gaEssentialOCL.getTypeLiteralWithMultiplicityCSAccess();
	}
	
	public ParserRule getTypeLiteralWithMultiplicityCSRule() {
		return getTypeLiteralWithMultiplicityCSAccess().getRule();
	}
	
	//TypeLiteralExpCS returns TypeLiteralExpCS:
	//    ownedType=TypeLiteralWithMultiplicityCS;
	public EssentialOCLGrammarAccess.TypeLiteralExpCSElements getTypeLiteralExpCSAccess() {
		return gaEssentialOCL.getTypeLiteralExpCSAccess();
	}
	
	public ParserRule getTypeLiteralExpCSRule() {
		return getTypeLiteralExpCSAccess().getRule();
	}
	
	//TypeNameExpCS returns TypeNameExpCS:
	//    ownedPathName=PathNameCS (ownedCurlyBracketedClause=CurlyBracketedClauseCS ('{' ownedPatternGuard=ExpCS '}')?)?;
	public EssentialOCLGrammarAccess.TypeNameExpCSElements getTypeNameExpCSAccess() {
		return gaEssentialOCL.getTypeNameExpCSAccess();
	}
	
	public ParserRule getTypeNameExpCSRule() {
		return getTypeNameExpCSAccess().getRule();
	}
	
	//TypeExpWithoutMultiplicityCS returns base::TypedRefCS:
	//    (TypeNameExpCS | TypeLiteralCS | CollectionPatternCS);
	public EssentialOCLGrammarAccess.TypeExpWithoutMultiplicityCSElements getTypeExpWithoutMultiplicityCSAccess() {
		return gaEssentialOCL.getTypeExpWithoutMultiplicityCSAccess();
	}
	
	public ParserRule getTypeExpWithoutMultiplicityCSRule() {
		return getTypeExpWithoutMultiplicityCSAccess().getRule();
	}
	
	//TypeExpCS returns base::TypedRefCS:
	//    TypeExpWithoutMultiplicityCS ownedMultiplicity=MultiplicityCS?;
	public EssentialOCLGrammarAccess.TypeExpCSElements getTypeExpCSAccess() {
		return gaEssentialOCL.getTypeExpCSAccess();
	}
	
	public ParserRule getTypeExpCSRule() {
		return getTypeExpCSAccess().getRule();
	}
	
	////---------------------------------------------------------------------
	////  Expressions
	////---------------------------------------------------------------------
	//// An ExpCS permits a LetExpCS only in the final term to ensure
	////  that let is right associative, whereas infix operators are left associative.
	////   a = 64 / 16 / let b : Integer in 8 / let c : Integer in 4
	//// is
	////   a = (64 / 16) / (let b : Integer in 8 / (let c : Integer in 4 ))
	///* An expression elaborates a prefixed expression with zero or more binary operator and expression suffixes.
	// * An optionally prefixed let expression is permitted except when suffixed with further expressions.*/
	//ExpCS returns ExpCS:
	////    ({InfixExpCS} ownedSource=PrefixedExpCS name=BinaryOperatorName ownedArgument=ExpCS)
	////|     PrefixedExpCS
	//// the above takes exponential or worse time for backtracking, below is fast
	//    (PrefixedPrimaryExpCS ({InfixExpCS.ownedLeft=current} name=BinaryOperatorName ownedRight=ExpCS)?)
	//|     PrefixedLetExpCS;
	public EssentialOCLGrammarAccess.ExpCSElements getExpCSAccess() {
		return gaEssentialOCL.getExpCSAccess();
	}
	
	public ParserRule getExpCSRule() {
		return getExpCSAccess().getRule();
	}
	
	///* A prefixed let expression elaborates a let expression with zero or more unary prefix operators. */
	//PrefixedLetExpCS returns ExpCS:
	//    ({PrefixExpCS} name=UnaryOperatorName ownedRight=PrefixedLetExpCS)
	//|     LetExpCS;
	public EssentialOCLGrammarAccess.PrefixedLetExpCSElements getPrefixedLetExpCSAccess() {
		return gaEssentialOCL.getPrefixedLetExpCSAccess();
	}
	
	public ParserRule getPrefixedLetExpCSRule() {
		return getPrefixedLetExpCSAccess().getRule();
	}
	
	///* A prefixed primary expression elaborates a primary expression with zero or more unary prefix operators. */
	//PrefixedPrimaryExpCS returns ExpCS:
	//    ({PrefixExpCS} name=UnaryOperatorName ownedRight=PrefixedPrimaryExpCS)
	//|     PrimaryExpCS;
	public EssentialOCLGrammarAccess.PrefixedPrimaryExpCSElements getPrefixedPrimaryExpCSAccess() {
		return gaEssentialOCL.getPrefixedPrimaryExpCSAccess();
	}
	
	public ParserRule getPrefixedPrimaryExpCSRule() {
		return getPrefixedPrimaryExpCSAccess().getRule();
	}
	
	///* A primary expression identifies the basic expressions from which more complex expressions may be constructed. */
	//PrimaryExpCS returns ExpCS:
	//    NestedExpCS
	//|    IfExpCS
	//|     SelfExpCS
	//|     PrimitiveLiteralExpCS
	//|     TupleLiteralExpCS
	//|     MapLiteralExpCS
	//|     CollectionLiteralExpCS
	//|     LambdaLiteralExpCS
	//|     TypeLiteralExpCS
	//|     NameExpCS;
	public EssentialOCLGrammarAccess.PrimaryExpCSElements getPrimaryExpCSAccess() {
		return gaEssentialOCL.getPrimaryExpCSAccess();
	}
	
	public ParserRule getPrimaryExpCSRule() {
		return getPrimaryExpCSAccess().getRule();
	}
	
	///* A name expression is a generalised rule for expressions that start with a name and which may be followed by square, round or
	// * curly bracket clauses and optionally an @pre as well.*/
	//NameExpCS returns NameExpCS:
	//    ownedPathName=PathNameCS ownedSquareBracketedClauses+=SquareBracketedClauseCS*
	//    ownedRoundBracketedClause=RoundBracketedClauseCS? ownedCurlyBracketedClause=CurlyBracketedClauseCS? (isPre?='@' 'pre')?;
	public EssentialOCLGrammarAccess.NameExpCSElements getNameExpCSAccess() {
		return gaEssentialOCL.getNameExpCSAccess();
	}
	
	public ParserRule getNameExpCSRule() {
		return getNameExpCSAccess().getRule();
	}
	
	///* A curly bracket clause is a generalized rule for the literal arguments of collections, maps, tuples and shadows.*/
	//CurlyBracketedClauseCS:
	//    {CurlyBracketedClauseCS} '{' ((ownedParts+=ShadowPartCS (',' ownedParts+=ShadowPartCS)*))? '}'
	//    ;
	public EssentialOCLGrammarAccess.CurlyBracketedClauseCSElements getCurlyBracketedClauseCSAccess() {
		return gaEssentialOCL.getCurlyBracketedClauseCSAccess();
	}
	
	public ParserRule getCurlyBracketedClauseCSRule() {
		return getCurlyBracketedClauseCSAccess().getRule();
	}
	
	///* A curly bracket clause is a generalized rule for template specialisations and operations arguments.*/
	//RoundBracketedClauseCS:
	//    {RoundBracketedClauseCS} '(' (ownedArguments+=NavigatingArgCS (ownedArguments+=(NavigatingCommaArgCS|NavigatingSemiArgCS|NavigatingBarArgCS))*)? ')'
	//    ;
	public EssentialOCLGrammarAccess.RoundBracketedClauseCSElements getRoundBracketedClauseCSAccess() {
		return gaEssentialOCL.getRoundBracketedClauseCSAccess();
	}
	
	public ParserRule getRoundBracketedClauseCSRule() {
		return getRoundBracketedClauseCSAccess().getRule();
	}
	
	///* A square bracket clause is a generalized rule for association class qualifiers and roles.*/
	//SquareBracketedClauseCS:
	//    '[' ownedTerms+=ExpCS (',' ownedTerms+=ExpCS)* ']';
	public EssentialOCLGrammarAccess.SquareBracketedClauseCSElements getSquareBracketedClauseCSAccess() {
		return gaEssentialOCL.getSquareBracketedClauseCSAccess();
	}
	
	public ParserRule getSquareBracketedClauseCSRule() {
		return getSquareBracketedClauseCSAccess().getRule();
	}
	
	///* A navigating argument is a generalized rule for the first argument in a round bracket clause. This is typically the first operation
	// * parameter or an iterator. */
	//NavigatingArgCS returns NavigatingArgCS:
	//    (ownedNameExpression=NavigatingArgExpCS (('<-' ownedCoIterator=CoIteratorVariableCS ('=' ownedInitExpression=ExpCS)?)
	//                                            |(':' ownedType=TypeExpCS ('<-' ownedCoIterator=CoIteratorVariableCS)? ('=' ownedInitExpression=ExpCS)?)
	//                                            | ((':' ownedType=TypeExpCS)? ('<-' ownedCoIterator=CoIteratorVariableCS)? 'in' ownedInitExpression=ExpCS)
	//                                            )?
	//    )
	//    | (':' ownedType=TypeExpCS);
	public EssentialOCLGrammarAccess.NavigatingArgCSElements getNavigatingArgCSAccess() {
		return gaEssentialOCL.getNavigatingArgCSAccess();
	}
	
	public ParserRule getNavigatingArgCSRule() {
		return getNavigatingArgCSAccess().getRule();
	}
	
	//    // Type-less init is an illegal infix expression
	///* A navigating bar argument is a generalized rule for a bar-prefixed argument in a round bracket clause. This is typically the body of an iteration. */
	//NavigatingBarArgCS returns NavigatingArgCS:
	//    prefix='|' ownedNameExpression=NavigatingArgExpCS (':' ownedType=TypeExpCS ('=' ownedInitExpression=ExpCS)?)?;
	public EssentialOCLGrammarAccess.NavigatingBarArgCSElements getNavigatingBarArgCSAccess() {
		return gaEssentialOCL.getNavigatingBarArgCSAccess();
	}
	
	public ParserRule getNavigatingBarArgCSRule() {
		return getNavigatingBarArgCSAccess().getRule();
	}
	
	//    // Type-less init is an illegal infix expression
	///* A navigating comma argument is a generalized rule for non-first argument in a round bracket clause. These are typically non-first operation
	// * parameters or a second iterator. */
	//NavigatingCommaArgCS returns NavigatingArgCS:
	//    prefix=',' ownedNameExpression=NavigatingArgExpCS (('<-' ownedCoIterator=CoIteratorVariableCS ('=' ownedInitExpression=ExpCS)?)
	//                                                      |(':' ownedType=TypeExpCS ('<-' ownedCoIterator=CoIteratorVariableCS)? ('=' ownedInitExpression=ExpCS)?)
	//                                                      | ((':' ownedType=TypeExpCS)? ('<-' ownedCoIterator=CoIteratorVariableCS)? 'in' ownedInitExpression=ExpCS)
	//                                                      )?;
	public EssentialOCLGrammarAccess.NavigatingCommaArgCSElements getNavigatingCommaArgCSAccess() {
		return gaEssentialOCL.getNavigatingCommaArgCSAccess();
	}
	
	public ParserRule getNavigatingCommaArgCSRule() {
		return getNavigatingCommaArgCSAccess().getRule();
	}
	
	//    // Type-less init is an illegal infix expression
	///* A navigating semi argument is a generalized rule for a semicolon prefixed argument in a round bracket clause. This is typically an iterate accumulator. */
	//NavigatingSemiArgCS returns NavigatingArgCS:
	//    prefix=';' ownedNameExpression=NavigatingArgExpCS (':' ownedType=TypeExpCS ('=' ownedInitExpression=ExpCS)?)?;
	public EssentialOCLGrammarAccess.NavigatingSemiArgCSElements getNavigatingSemiArgCSAccess() {
		return gaEssentialOCL.getNavigatingSemiArgCSAccess();
	}
	
	public ParserRule getNavigatingSemiArgCSRule() {
		return getNavigatingSemiArgCSAccess().getRule();
	}
	
	//    // Type-less init is an illegal infix expression
	//NavigatingArgExpCS returns ExpCS: // Intended to be overridden
	//    ExpCS
	//    //    '?'    -- defined by Complete OCL
	//;
	public EssentialOCLGrammarAccess.NavigatingArgExpCSElements getNavigatingArgExpCSAccess() {
		return gaEssentialOCL.getNavigatingArgExpCSAccess();
	}
	
	public ParserRule getNavigatingArgExpCSRule() {
		return getNavigatingArgExpCSAccess().getRule();
	}
	
	//CoIteratorVariableCS returns VariableCS:
	//    name=UnrestrictedName (':' ownedType=TypeExpCS)?;
	public EssentialOCLGrammarAccess.CoIteratorVariableCSElements getCoIteratorVariableCSAccess() {
		return gaEssentialOCL.getCoIteratorVariableCSAccess();
	}
	
	public ParserRule getCoIteratorVariableCSRule() {
		return getCoIteratorVariableCSAccess().getRule();
	}
	
	//IfExpCS returns IfExpCS:
	//    'if' ownedCondition=(ExpCS|PatternExpCS)
	//    'then' ownedThenExpression=ExpCS
	////    ifThenExpressions+=IfThenExpCS
	//    (ownedIfThenExpressions+=ElseIfThenExpCS)*
	//    'else' ownedElseExpression=ExpCS
	//    'endif';
	public EssentialOCLGrammarAccess.IfExpCSElements getIfExpCSAccess() {
		return gaEssentialOCL.getIfExpCSAccess();
	}
	
	public ParserRule getIfExpCSRule() {
		return getIfExpCSAccess().getRule();
	}
	
	////IfThenExpCS returns IfThenExpCS:
	////    'if' condition=ExpCS
	////    'then' thenExpression=ExpCS
	////;
	//ElseIfThenExpCS returns IfThenExpCS:
	//    'elseif' ownedCondition=ExpCS
	//    'then' ownedThenExpression=ExpCS
	//;
	public EssentialOCLGrammarAccess.ElseIfThenExpCSElements getElseIfThenExpCSAccess() {
		return gaEssentialOCL.getElseIfThenExpCSAccess();
	}
	
	public ParserRule getElseIfThenExpCSRule() {
		return getElseIfThenExpCSAccess().getRule();
	}
	
	//LetExpCS returns LetExpCS:
	//    'let' ownedVariables+=LetVariableCS (',' ownedVariables+=LetVariableCS)*
	//    'in' ownedInExpression=ExpCS;
	public EssentialOCLGrammarAccess.LetExpCSElements getLetExpCSAccess() {
		return gaEssentialOCL.getLetExpCSAccess();
	}
	
	public ParserRule getLetExpCSRule() {
		return getLetExpCSAccess().getRule();
	}
	
	//LetVariableCS returns LetVariableCS:
	//    name=UnrestrictedName ownedRoundBracketedClause=RoundBracketedClauseCS? (':' ownedType=TypeExpCS)? '=' ownedInitExpression=ExpCS;
	public EssentialOCLGrammarAccess.LetVariableCSElements getLetVariableCSAccess() {
		return gaEssentialOCL.getLetVariableCSAccess();
	}
	
	public ParserRule getLetVariableCSRule() {
		return getLetVariableCSAccess().getRule();
	}
	
	//NestedExpCS returns NestedExpCS:
	//    '(' ownedExpression=ExpCS ')';
	public EssentialOCLGrammarAccess.NestedExpCSElements getNestedExpCSAccess() {
		return gaEssentialOCL.getNestedExpCSAccess();
	}
	
	public ParserRule getNestedExpCSRule() {
		return getNestedExpCSAccess().getRule();
	}
	
	//SelfExpCS returns SelfExpCS:
	//    {SelfExpCS} 'self';
	public EssentialOCLGrammarAccess.SelfExpCSElements getSelfExpCSAccess() {
		return gaEssentialOCL.getSelfExpCSAccess();
	}
	
	public ParserRule getSelfExpCSRule() {
		return getSelfExpCSAccess().getRule();
	}
	
	//MultiplicityBoundsCS returns MultiplicityBoundsCS:
	//     lowerBound=LOWER ('..' upperBound=UPPER)?;
	public BaseGrammarAccess.MultiplicityBoundsCSElements getMultiplicityBoundsCSAccess() {
		return gaBase.getMultiplicityBoundsCSAccess();
	}
	
	public ParserRule getMultiplicityBoundsCSRule() {
		return getMultiplicityBoundsCSAccess().getRule();
	}
	
	//MultiplicityCS returns MultiplicityCS:
	//    '[' (MultiplicityBoundsCS | MultiplicityStringCS) ('|?' | isNullFree?='|1')? ']';
	public BaseGrammarAccess.MultiplicityCSElements getMultiplicityCSAccess() {
		return gaBase.getMultiplicityCSAccess();
	}
	
	public ParserRule getMultiplicityCSRule() {
		return getMultiplicityCSAccess().getRule();
	}
	
	//MultiplicityStringCS returns MultiplicityStringCS:
	//    stringBounds=('*'|'+'|'?');
	public BaseGrammarAccess.MultiplicityStringCSElements getMultiplicityStringCSAccess() {
		return gaBase.getMultiplicityStringCSAccess();
	}
	
	public ParserRule getMultiplicityStringCSRule() {
		return getMultiplicityStringCSAccess().getRule();
	}
	
	//PathNameCS returns PathNameCS:
	//    ownedPathElements+=FirstPathElementCS ('::' ownedPathElements+=NextPathElementCS)*;
	public BaseGrammarAccess.PathNameCSElements getPathNameCSAccess() {
		return gaBase.getPathNameCSAccess();
	}
	
	public ParserRule getPathNameCSRule() {
		return getPathNameCSAccess().getRule();
	}
	
	//FirstPathElementCS returns PathElementCS:
	//    referredElement=[pivot::NamedElement|UnrestrictedName];
	public BaseGrammarAccess.FirstPathElementCSElements getFirstPathElementCSAccess() {
		return gaBase.getFirstPathElementCSAccess();
	}
	
	public ParserRule getFirstPathElementCSRule() {
		return getFirstPathElementCSAccess().getRule();
	}
	
	//NextPathElementCS returns PathElementCS:
	//    referredElement=[pivot::NamedElement|UnreservedName];
	public BaseGrammarAccess.NextPathElementCSElements getNextPathElementCSAccess() {
		return gaBase.getNextPathElementCSAccess();
	}
	
	public ParserRule getNextPathElementCSRule() {
		return getNextPathElementCSAccess().getRule();
	}
	
	//TemplateBindingCS returns TemplateBindingCS:
	//    ownedSubstitutions+=TemplateParameterSubstitutionCS (',' ownedSubstitutions+=TemplateParameterSubstitutionCS)* (ownedMultiplicity=MultiplicityCS)?
	//;
	public BaseGrammarAccess.TemplateBindingCSElements getTemplateBindingCSAccess() {
		return gaBase.getTemplateBindingCSAccess();
	}
	
	public ParserRule getTemplateBindingCSRule() {
		return getTemplateBindingCSAccess().getRule();
	}
	
	//TemplateParameterSubstitutionCS returns TemplateParameterSubstitutionCS:
	//    ownedActualParameter=TypeRefCS
	//;
	public BaseGrammarAccess.TemplateParameterSubstitutionCSElements getTemplateParameterSubstitutionCSAccess() {
		return gaBase.getTemplateParameterSubstitutionCSAccess();
	}
	
	public ParserRule getTemplateParameterSubstitutionCSRule() {
		return getTemplateParameterSubstitutionCSAccess().getRule();
	}
	
	//TemplateSignatureCS returns TemplateSignatureCS:
	//    '(' ownedParameters+=TypeParameterCS (',' ownedParameters+=TypeParameterCS)* ')'
	//;
	public BaseGrammarAccess.TemplateSignatureCSElements getTemplateSignatureCSAccess() {
		return gaBase.getTemplateSignatureCSAccess();
	}
	
	public ParserRule getTemplateSignatureCSRule() {
		return getTemplateSignatureCSAccess().getRule();
	}
	
	//TypeParameterCS returns TypeParameterCS:
	//    name=UnrestrictedName
	//    ('extends' ownedExtends+=TypedRefCS ('&&' ownedExtends+=TypedRefCS)*)?
	//;
	public BaseGrammarAccess.TypeParameterCSElements getTypeParameterCSAccess() {
		return gaBase.getTypeParameterCSAccess();
	}
	
	public ParserRule getTypeParameterCSRule() {
		return getTypeParameterCSAccess().getRule();
	}
	
	//TypeRefCS returns TypeRefCS:
	//    TypedRefCS | WildcardTypeRefCS
	//;
	public BaseGrammarAccess.TypeRefCSElements getTypeRefCSAccess() {
		return gaBase.getTypeRefCSAccess();
	}
	
	public ParserRule getTypeRefCSRule() {
		return getTypeRefCSAccess().getRule();
	}
	
	//TypedRefCS returns TypedRefCS:
	//    TypedTypeRefCS
	//;
	public BaseGrammarAccess.TypedRefCSElements getTypedRefCSAccess() {
		return gaBase.getTypedRefCSAccess();
	}
	
	public ParserRule getTypedRefCSRule() {
		return getTypedRefCSAccess().getRule();
	}
	
	//TypedTypeRefCS returns TypedTypeRefCS:
	//    ownedPathName=PathNameCS ('(' ownedBinding=TemplateBindingCS ')')?
	//;
	public BaseGrammarAccess.TypedTypeRefCSElements getTypedTypeRefCSAccess() {
		return gaBase.getTypedTypeRefCSAccess();
	}
	
	public ParserRule getTypedTypeRefCSRule() {
		return getTypedTypeRefCSAccess().getRule();
	}
	
	//WildcardTypeRefCS returns WildcardTypeRefCS:
	//    {WildcardTypeRefCS} '?' ('extends' ownedExtends=TypedRefCS)?
	//;
	public BaseGrammarAccess.WildcardTypeRefCSElements getWildcardTypeRefCSAccess() {
		return gaBase.getWildcardTypeRefCSAccess();
	}
	
	public ParserRule getWildcardTypeRefCSRule() {
		return getWildcardTypeRefCSAccess().getRule();
	}
	
	//ID: SIMPLE_ID | ESCAPED_ID;
	public BaseGrammarAccess.IDElements getIDAccess() {
		return gaBase.getIDAccess();
	}
	
	public ParserRule getIDRule() {
		return getIDAccess().getRule();
	}
	
	//Identifier:
	//    ID;
	public BaseGrammarAccess.IdentifierElements getIdentifierAccess() {
		return gaBase.getIdentifierAccess();
	}
	
	public ParserRule getIdentifierRule() {
		return getIdentifierAccess().getRule();
	}
	
	///* A lowerbounded integer is used to define the lowerbound of a collection multiplicity. The value may not be the unlimited value. */
	//LOWER returns ecore::EInt:
	//    INT
	//;
	public BaseGrammarAccess.LOWERElements getLOWERAccess() {
		return gaBase.getLOWERAccess();
	}
	
	public ParserRule getLOWERRule() {
		return getLOWERAccess().getRule();
	}
	
	///* A number may be an integer or floating point value. The declaration here appears to be that for just an integer. This is to avoid
	// * lookahead conflicts in simple lexers between a dot within a floating point number and the dot-dot in a CollectionLiteralPartCS. A
	// * practical implementation should give high priority to a successful parse of INT ('.' INT)? (('e' | 'E') ('+' | '-')? INT)? than
	// * to the unsuccessful partial parse of INT '..'. The type of the INT terminal is String to allow the floating point syntax to be used.
	// */
	//NUMBER_LITERAL returns BigNumber: // Not terminal to allow parser backtracking to sort out "5..7"
	//    INT;
	public BaseGrammarAccess.NUMBER_LITERALElements getNUMBER_LITERALAccess() {
		return gaBase.getNUMBER_LITERALAccess();
	}
	
	public ParserRule getNUMBER_LITERALRule() {
		return getNUMBER_LITERALAccess().getRule();
	}
	
	// // EssentialOCLTokenSource pieces this together ('.' INT)? (('e' | 'E') ('+' | '-')? INT)?;
	//StringLiteral:
	//    SINGLE_QUOTED_STRING;
	public BaseGrammarAccess.StringLiteralElements getStringLiteralAccess() {
		return gaBase.getStringLiteralAccess();
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}
	
	///* An upperbounded integer is used to define the upperbound of a collection multiplicity. The value may be the unlimited value. */
	//UPPER returns ecore::EInt:
	//    INT | '*'
	//;
	public BaseGrammarAccess.UPPERElements getUPPERAccess() {
		return gaBase.getUPPERAccess();
	}
	
	public ParserRule getUPPERRule() {
		return getUPPERAccess().getRule();
	}
	
	//URI:
	//    SINGLE_QUOTED_STRING;
	public BaseGrammarAccess.URIElements getURIAccess() {
		return gaBase.getURIAccess();
	}
	
	public ParserRule getURIRule() {
		return getURIAccess().getRule();
	}
	
	//terminal fragment ESCAPED_CHARACTER:
	//    '\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\');
	public TerminalRule getESCAPED_CHARACTERRule() {
		return gaBase.getESCAPED_CHARACTERRule();
	}
	
	//terminal fragment LETTER_CHARACTER:
	//    'a'..'z' | 'A'..'Z' | '_';
	public TerminalRule getLETTER_CHARACTERRule() {
		return gaBase.getLETTER_CHARACTERRule();
	}
	
	//terminal DOUBLE_QUOTED_STRING:
	//    '"' (ESCAPED_CHARACTER | !('\\' | '"'))* '"';
	public TerminalRule getDOUBLE_QUOTED_STRINGRule() {
		return gaBase.getDOUBLE_QUOTED_STRINGRule();
	}
	
	//terminal SINGLE_QUOTED_STRING:
	//    "'" (ESCAPED_CHARACTER | !('\\' | "'"))* "'";
	public TerminalRule getSINGLE_QUOTED_STRINGRule() {
		return gaBase.getSINGLE_QUOTED_STRINGRule();
	}
	
	//terminal ML_SINGLE_QUOTED_STRING:
	//    "/'"->"'/";
	public TerminalRule getML_SINGLE_QUOTED_STRINGRule() {
		return gaBase.getML_SINGLE_QUOTED_STRINGRule();
	}
	
	//terminal SIMPLE_ID:
	//    LETTER_CHARACTER (LETTER_CHARACTER | ('0'..'9'))*;
	public TerminalRule getSIMPLE_IDRule() {
		return gaBase.getSIMPLE_IDRule();
	}
	
	//terminal ESCAPED_ID:
	//    "_" SINGLE_QUOTED_STRING;
	public TerminalRule getESCAPED_IDRule() {
		return gaBase.getESCAPED_IDRule();
	}
	
	//terminal INT: // String to allow diverse re-use
	//    ('0'..'9')+;
	public TerminalRule getINTRule() {
		return gaBase.getINTRule();
	}
	
	//        // multiple leading zeroes occur as floating point fractional part
	///* A multi-line comment supports a comment that may span more than one line using familiar slash-star...star-slash comment delimiters */
	//terminal ML_COMMENT:
	//    '/*' ->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaBase.getML_COMMENTRule();
	}
	
	///* A single-line comment supports a comment that terminates at the end of the line */
	//terminal SL_COMMENT:
	//    '--' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaBase.getSL_COMMENTRule();
	}
	
	///* Whitespace may occur between any pair of tokens */
	//terminal WS:
	//    (' ' | '\t' | '\r' | '\n')+;
	public TerminalRule getWSRule() {
		return gaBase.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//    .;
	public TerminalRule getANY_OTHERRule() {
		return gaBase.getANY_OTHERRule();
	}
}
